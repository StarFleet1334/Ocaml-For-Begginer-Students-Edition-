Hello - from /Users/ilialataria/.vscode/extensions/jaredly.reason-vscode-1.7.13/bin.native
Previous log location: /var/folders/gq/p4ql2shn339dc461mdlsdcf00000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","languageId":"ocaml","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 5, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":2},"contentChanges":[{"text":"()"}]}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":0,"character":1}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00405311584473ms
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":4},"contentChanges":[{"text":"(** *)"}]}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":0,"character":3},"end":{"line":0,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 9, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":7},"contentChanges":[{"text":"(**\n    \n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":3,"character":0},"end":{"line":3,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0560283660889ms
Sending response {"id": 12, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 14, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":8},"contentChanges":[{"text":"(**\n    \n  \n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 15, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":9},"contentChanges":[{"text":"(**\n    \n  ()\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":2,"character":3}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00309944152832ms
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":11},"contentChanges":[{"text":"(**\n    \n  (BN)\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":2,"character":5},"end":{"line":2,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 19, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":12},"contentChanges":[{"text":"(**\n    \n  (B)\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":2,"character":4},"end":{"line":2,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0319480895996ms
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 22, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":16},"contentChanges":[{"text":"(**\n    \n  (Not)\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":2,"character":6},"end":{"line":2,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 25, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":17},"contentChanges":[{"text":"(**\n    \n  (Not )\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":2,"character":7},"end":{"line":2,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 28, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":18},"contentChanges":[{"text":"(**\n    \n  (Not)\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":2,"character":6},"end":{"line":2,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0231266021729ms
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 31, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":20},"contentChanges":[{"text":"(**\n    \n  (Not) M\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":28},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating \n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":33},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":2,"character":22},"end":{"line":2,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 33, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 34, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 35, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":34},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n  \n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":35},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  \n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0269412994385ms
Sending response {"id": 36, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":36},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 38, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":2},"end":{"line":5,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":41,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 41, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":39},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":42,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 42, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":43,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 43, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":44,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 44, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":45,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0338554382324ms
Sending response {"id": 45, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":46,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 46, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":40},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n  \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":47,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 47, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":48,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 48, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":41},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":49,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 49, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":50,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 50, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":46},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":51},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":53},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are mu\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":54},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are mut\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":51,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":15},"end":{"line":4,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 51, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":52,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0841617584229ms
Sending response {"id": 52, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":53,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 53, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":56},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are m\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":54,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":13},"end":{"line":4,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 54, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":55,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 55, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":56,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 56, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":57},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":59},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are im\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":57,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":14},"end":{"line":4,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 57, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":58,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 58, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":59,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 59, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":60},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are imm\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":65},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutasb\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":67},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutasble\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":60,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":22},"end":{"line":4,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 60, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":61,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 61, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":62,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00977516174316ms
Sending response {"id": 62, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":70},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutas\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":63,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":19},"end":{"line":4,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0290870666504ms
Sending response {"id": 63, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":64,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 64, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":65,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 65, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":71},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immuta\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":75},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable,\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":66,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":22},"end":{"line":4,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 66, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":67,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00190734863281ms
Sending response {"id": 67, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":68,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 68, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":76},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":69,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 69, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":77},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, T\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":70,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 70, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":79},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, The\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":86},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":89},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no wa\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":90},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":91},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":71,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0112056732178ms
Sending response {"id": 71, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":72,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 72, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":99},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to chang\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":101},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":110},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an elemen\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":111},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an elemen \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":120},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a l\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":73,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":65},"end":{"line":4,"character":65}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.018835067749ms
Sending response {"id": 73, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":73}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":121},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a ls\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":74,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":66},"end":{"line":4,"character":66}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 74, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":131},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":75,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.018835067749ms
Sending response {"id": 75, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":76,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 76, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":138},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one val\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":143},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":144},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":149},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to anoth\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":152},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":77,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":4,"character":95},"end":{"line":4,"character":95}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0171661376953ms
Sending response {"id": 77, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":78,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 78, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":79,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 79, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":153},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":80,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 80, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":81,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 81, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":157},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Inst\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":82,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":6},"end":{"line":5,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 82, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":83,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 83, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":84,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 84, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":161},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":85,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 85, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":86,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 86, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":162},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead O\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":87,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":11},"end":{"line":5,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 87, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":88,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 88, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":89,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 89, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":166},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead Ocaml\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":90,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":15},"end":{"line":5,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 90, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":91,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 91, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":92,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 92, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":177},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":93,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 93, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":94,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 94, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":189},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":190},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers c\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":191},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers cr\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":194},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers creat\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":200},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":201},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new l\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":95,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":40},"end":{"line":5,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 95, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":96,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 96, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":97,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 97, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":206},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":98,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 98, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":207},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists o\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":99,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 99, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":210},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":213},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":216},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of odl\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":55},"end":{"line":5,"character":55}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 100, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":101,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 101, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":102,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 102, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":217},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of od\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":221},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":227},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":103,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":5,"character":62},"end":{"line":5,"character":62}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 103, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":104,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 104, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":105,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 105, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":229},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n  \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":106,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0319480895996ms
Sending response {"id": 106, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":107,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 107, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":231},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n  1.\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":108,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":7,"character":4},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 108, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":232},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n  1. \n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":109,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 109, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":110,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 110, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":236},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":111,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 111, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":112,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 112, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":113,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0319480895996ms
Sending response {"id": 113, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":238},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":114,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 114, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":115,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 115, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":240},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":116,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 116, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":117,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 117, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":241},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nl\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":118,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":10,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 118, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":119,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":1},"end":{"line":10,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 119, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":120,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 120, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":121,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 121, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":242},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlt\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":122,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":2},"end":{"line":10,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 122, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":123,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 123, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":124,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 124, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":246},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":247},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet i\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":125,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":10,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 125, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":249},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":126,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":7},"end":{"line":10,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 126, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":127,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 127, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":128,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 128, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":250},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":251},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_f\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":129,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":10,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 129, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":255},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":130,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":13},"end":{"line":10,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 130, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":131,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 131, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":132,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 132, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":256},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":133,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 133, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":134,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 134, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":258},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first ls\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":263},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":135,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 135, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":136,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 136, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":264},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  m\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":137,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 137, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":265},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  ma\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":266},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  mat\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":268},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":270},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":138,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 138, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":271},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match ls\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":274},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst w\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":139,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 139, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":275},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst wi\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":140,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":14},"end":{"line":11,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 140, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":141,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 141, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":142,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 142, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":278},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":143,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":16},"end":{"line":11,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 143, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":144,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0238418579102ms
Sending response {"id": 144, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":145,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 145, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":279},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":146,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 146, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":147,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 147, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":280},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  }\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":148,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":3},"end":{"line":12,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 148, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":149,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 149, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":150,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 150, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":281},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":282},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  |\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":283},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":151,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 151, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":152,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 152, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":286},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":153,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 153, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":154,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 154, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":287},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] =\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":155,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":8},"end":{"line":12,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 155, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":156,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 156, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":157,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 157, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":288},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":289},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":158,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":8},"end":{"line":12,"character":8}},"context":{"diagnostics":[{"range":{"start":{"line":12,"character":7},"end":{"line":12,"character":8}},"message":"Syntax error, expecting pattern","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0391006469727ms
Sending response {"id": 158, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":159,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 159, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":160,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 160, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":291},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":161,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0238418579102ms
Sending response {"id": 161, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":162,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 162, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":292},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":163,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":11},"end":{"line":12,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 163, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":164,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 164, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":165,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 165, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":293},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":166,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 166, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":167,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 167, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":294},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  |\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":295},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":168,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 168, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":169,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 169, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":300},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":170,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 170, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":171,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 171, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":303},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":172,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":12},"end":{"line":13,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 172, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":173,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 173, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":174,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 174, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":305},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":175,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 175, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":176,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 176, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":306},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> ()\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":177,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":13,"character":15}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00405311584473ms
Sending response {"id": 177, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":307},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":178,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":13,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 178, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":179,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":16},"end":{"line":13,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 179, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":180,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 180, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":181,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 181, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":308},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":182,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":17},"end":{"line":13,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 182, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":183,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 183, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":309},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":184,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 184, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":185,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":19},"end":{"line":13,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 185, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":186,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 186, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":310},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":312},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) ::\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":313},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":187,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 187, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":188,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 188, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":314},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":189,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":13,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0147819519043ms
Sending response {"id": 189, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":190,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":24},"end":{"line":13,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 190, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":191,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 191, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":192,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 192, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":315},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":193,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":24},"end":{"line":13,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 193, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":194,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 194, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":195,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 195, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":317},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":196,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":26},"end":{"line":13,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 196, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":197,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 197, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":198,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 198, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":199,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 199, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":200,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0379085540771ms
Sending response {"id": 200, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":318},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n()\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":201,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":9,"character":1}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00596046447754ms
Sending response {"id": 201, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":202,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":9,"character":1},"end":{"line":9,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 202, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":203,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 203, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":204,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 204, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":320},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(** *)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":205,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":9,"character":3},"end":{"line":9,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 205, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":206,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 206, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":207,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 207, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":322},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\n    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":208,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":0},"end":{"line":11,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 208, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":209,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 209, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":210,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0209808349609ms
Sending response {"id": 210, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":211,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 211, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":323},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nS    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":324},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSu    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":327},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppo    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":212,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":5},"end":{"line":10,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 212, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":213,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 213, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":214,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 214, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":330},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":215,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 215, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":216,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 216, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":331},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":217,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":7},"end":{"line":10,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 217, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":218,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 218, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":219,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0219345092773ms
Sending response {"id": 219, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":338},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wan    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":339},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we want    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":220,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":15},"end":{"line":10,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 220, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":221,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 221, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":222,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 222, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":344},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":349},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to writ    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":357},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a func    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":369},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that re    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":372},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that retur    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":376},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":223,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 223, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":224,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 224, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":385},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":386},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same l    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":393},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":225,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 225, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":226,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 226, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":394},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as n    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":227,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":70},"end":{"line":10,"character":70}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 227, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":228,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 228, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":229,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 229, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":395},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":230,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 230, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":396},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as i    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":231,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 231, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":398},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as inp    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":232,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":72},"end":{"line":10,"character":72}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 232, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":233,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 233, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":234,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 234, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":401},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":402},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input l    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":404},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input lis    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":407},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input listm,    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":235,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":81},"end":{"line":10,"character":81}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 235, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":236,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 236, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":237,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 237, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":409},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":410},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input listm    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":411},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input listm\n    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":238,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 238, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":239,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 239, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":413},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":240,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":79},"end":{"line":10,"character":79}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0388622283936ms
Sending response {"id": 240, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":241,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 241, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":242,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 242, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":415},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\n    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":243,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 243, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":244,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 244, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":420},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut w    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":245,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":5},"end":{"line":11,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 245, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":246,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 246, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":247,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 247, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":423},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":441},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":248,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":26},"end":{"line":11,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 248, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":249,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 249, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":250,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 250, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":442},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element()    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":251,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":27}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00500679016113ms
Sending response {"id": 251, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":252,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":27},"end":{"line":11,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 252, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":253,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 253, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":254,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 254, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":445},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element ()    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":255,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":28}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00405311584473ms
Sending response {"id": 255, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":256,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":28},"end":{"line":11,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 256, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":257,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 257, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":258,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 258, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":451},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if the)    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":457},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is )    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":259,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":40},"end":{"line":11,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0271797180176ms
Sending response {"id": 259, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":260,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 260, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":261,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 261, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":459},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is on)    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":460},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one)    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":262,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":43},"end":{"line":11,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0288486480713ms
Sending response {"id": 262, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":263,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 263, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":264,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 264, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":265,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":10,"character":43}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0112056732178ms
Sending response {"id": 265, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":461},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that  returend the same list as input list,\nbut with the first element (if there is one)    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":266,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":44},"end":{"line":10,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.028133392334ms
Sending response {"id": 266, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":267,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 267, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":268,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 268, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":462},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one)    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":269,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":10,"character":43},"end":{"line":10,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 269, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":270,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 270, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":271,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 271, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":272,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":11,"character":43}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0100135803223ms
Sending response {"id": 272, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":273,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":44},"end":{"line":11,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 273, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":274,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 274, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":463},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one)     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":275,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 275, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":276,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 276, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":466},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) inc    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":472},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) increment    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":475},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":476},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented b    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":477},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":478},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by     \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":482},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":277,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":11,"character":64},"end":{"line":11,"character":64}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 277, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":278,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 278, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":279,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 279, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":280,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":14,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 280, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":281,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":15,"character":12},"end":{"line":15,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 281, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":282,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 282, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":283,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":26},"end":{"line":16,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 283, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":284,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 284, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":285,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 285, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":286,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":8},"end":{"line":16,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 286, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":287,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 287, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":288,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":1},"end":{"line":16,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 288, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":289,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 289, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":290,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":0},"end":{"line":16,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0548362731934ms
Sending response {"id": 290, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":291,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 291, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":292,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 292, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":293,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":16,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0178813934326ms
Sending response {"id": 293, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":294,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":16,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.018835067749ms
Sending response {"id": 294, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":295,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":16,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 295, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":296,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":19},"end":{"line":16,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 296, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":297,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 297, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":298,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":16,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0290870666504ms
Sending response {"id": 298, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":483},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1 :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":299,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":18},"end":{"line":16,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Sending response {"id": 299, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":300,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 300, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":301,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 301, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":302,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":16,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0150203704834ms
Sending response {"id": 302, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":484},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> h+1 :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":303,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":14},"end":{"line":16,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 303, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":304,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 304, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":305,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0231266021729ms
Sending response {"id": 305, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":306,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":14},"end":{"line":16,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 306, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":307,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":23},"end":{"line":16,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 307, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":308,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 308, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":309,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":0},"end":{"line":16,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 309, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":310,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 310, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":311,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":0},"end":{"line":13,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 311, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":312,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 312, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":313,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":0},"end":{"line":16,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 313, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":314,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 314, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":315,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 315, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":485},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1 :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":316,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":15},"end":{"line":16,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 316, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":317,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 317, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":318,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 318, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":486},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":319,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":16,"character":19},"end":{"line":16,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 319, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":320,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 320, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":321,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 321, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":322,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 322, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":323,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":0},"end":{"line":16,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0500679016113ms
Sending response {"id": 323, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":324,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 324, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":325,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":13,"character":0},"end":{"line":16,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 325, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":326,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 326, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":327,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 327, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":328,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"range":{"start":{"line":12,"character":2},"end":{"line":12,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 328, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":329,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 329, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":486},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":486}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":330,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":4,"character":14}}}
[server] Got a method textDocument/definition
[server] processing took 0.00596046447754ms
Sending response {"id": 330, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":331,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"},"position":{"line":2,"character":14}}}
[server] Got a method textDocument/definition
[server] processing took 0.00715255737305ms
Sending response {"id": 331, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":332,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 332, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":486},"contentChanges":[{"text":"(**\n    \n  (Not) Mutating Lists\n\n  Lists are immutable, There's no way to change an element of a list from one value to another.\n  Instead OCaml programmers create new lists out of old lists.\n\n*)\n\n(**\nSuppose we wanted to write a function that returend the same list as input list,\nbut with the first element (if there is one) incremented by one.    \n*)\nlet inc_first lst = \n  match lst with\n  | [] -> []\n  | h :: t -> (h+1) :: t;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml","version":486}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/second_chapter/main.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","languageId":"ocaml","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":333,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 333, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":334,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 334, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2},"contentChanges":[{"text":"()"}]}}
Read message 
{"jsonrpc":"2.0","id":335,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":0,"character":1}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00381469726562ms
Sending response {"id": 335, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":336,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":0,"character":1},"end":{"line":0,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00476837158203ms
Sending response {"id": 336, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":337,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 337, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":338,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0331401824951ms
Sending response {"id": 338, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":4},"contentChanges":[{"text":"(** *)"}]}}
Read message 
{"jsonrpc":"2.0","id":339,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":0,"character":3},"end":{"line":0,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 339, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":340,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 340, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":341,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 341, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":6},"contentChanges":[{"text":"(**\n    \n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":342,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":2,"character":0},"end":{"line":2,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 342, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":343,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 343, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":344,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0219345092773ms
Sending response {"id": 344, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":345,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 345, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":7},"contentChanges":[{"text":"(**\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":346,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 346, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":347,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 347, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":8},"contentChanges":[{"text":"(**\n  \n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":348,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 348, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":349,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 349, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":9},"contentChanges":[{"text":"(**\n  p\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":350,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":3},"end":{"line":1,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 350, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":351,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 351, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":352,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 352, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":10},"contentChanges":[{"text":"(**\n  pa\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":353,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":4},"end":{"line":1,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 353, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":354,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 354, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":355,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 355, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":12},"contentChanges":[{"text":"(**\n  patt\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":356,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":6},"end":{"line":1,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 356, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":357,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 357, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":358,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 358, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":17},"contentChanges":[{"text":"(**\n  P\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":359,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":3},"end":{"line":1,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 359, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":360,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 360, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":361,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 361, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":18},"contentChanges":[{"text":"(**\n  Pa\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":362,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":4},"end":{"line":1,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 362, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":363,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 363, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":364,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 364, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":19},"contentChanges":[{"text":"(**\n  Pat\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":365,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":5},"end":{"line":1,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 365, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":366,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 366, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":367,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 367, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":20},"contentChanges":[{"text":"(**\n  Patt\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":368,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":6},"end":{"line":1,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 368, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":369,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 369, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":370,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 370, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":24},"contentChanges":[{"text":"(**\n  Pattern \n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":371,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 371, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":372,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 372, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":27},"contentChanges":[{"text":"(**\n  Pattern Mat\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":373,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":13},"end":{"line":1,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 373, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":373}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":33},"contentChanges":[{"text":"(**\n  Pattern Matching \n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":36},"contentChanges":[{"text":"(**\n  Pattern Matching wit\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":37},"contentChanges":[{"text":"(**\n  Pattern Matching with\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":38},"contentChanges":[{"text":"(**\n  Pattern Matching with \n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":39},"contentChanges":[{"text":"(**\n  Pattern Matching with L\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":43},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":374,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":29},"end":{"line":1,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 374, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":375,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 375, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":376,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 376, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":377,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0269412994385ms
Sending response {"id": 377, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":44},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":378,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0381469726562ms
Sending response {"id": 378, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":379,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":1,"character":29},"end":{"line":1,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 379, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":380,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0247955322266ms
Sending response {"id": 380, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":46},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":381,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 381, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":382,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 382, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":46},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":46}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":47},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nS"}]}}
Read message 
{"jsonrpc":"2.0","id":383,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":4,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 383, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":384,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":4,"character":1},"end":{"line":4,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 384, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":385,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 385, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":386,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 386, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":387,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":4,"character":1},"end":{"line":4,"character":1}},"context":{"diagnostics":[{"range":{"start":{"line":4,"character":0},"end":{"line":4,"character":1}},"message":"Unbound constructor S","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 387, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":48},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSn"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":49},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nS"}]}}
Read message 
{"jsonrpc":"2.0","id":388,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":4,"character":1},"end":{"line":4,"character":1}},"context":{"diagnostics":[{"range":{"start":{"line":4,"character":0},"end":{"line":4,"character":1}},"message":"Unbound constructor S","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 388, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":389,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 389, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":390,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 390, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":51},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyn"}]}}
Read message 
{"jsonrpc":"2.0","id":391,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":4,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 391, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":52},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSynt"}]}}
Read message 
{"jsonrpc":"2.0","id":392,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":4,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 392, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":392}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":55},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\n"}]}}
Read message 
{"jsonrpc":"2.0","id":393,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 393, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":394,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 394, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":56},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nm"}]}}
Read message 
{"jsonrpc":"2.0","id":395,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":5,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 395, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":60},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":61},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":62},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e"}]}}
Read message 
{"jsonrpc":"2.0","id":396,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":5,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 396, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":64},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e w"}]}}
Read message 
{"jsonrpc":"2.0","id":397,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":5,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 397, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":65},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e wi"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":67},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with"}]}}
Read message 
{"jsonrpc":"2.0","id":398,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":5,"character":12},"end":{"line":5,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 398, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":399,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 399, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":400,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 400, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":68},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with"}]}}
Read message 
{"jsonrpc":"2.0","id":401,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0319480895996ms
Sending response {"id": 401, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":402,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 402, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":69},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n"}]}}
Read message 
{"jsonrpc":"2.0","id":403,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 403, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":70},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n|"}]}}
Read message 
{"jsonrpc":"2.0","id":404,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 404, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":405,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":1},"end":{"line":6,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 405, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":406,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0271797180176ms
Sending response {"id": 406, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":72},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p"}]}}
Read message 
{"jsonrpc":"2.0","id":407,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":6,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 407, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":408,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":3},"end":{"line":6,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 408, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":409,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 409, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":410,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 410, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":73},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1"}]}}
Read message 
{"jsonrpc":"2.0","id":411,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":6,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 411, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":74},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 "}]}}
Read message 
{"jsonrpc":"2.0","id":412,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 412, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":413,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 413, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":75},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -"}]}}
Read message 
{"jsonrpc":"2.0","id":414,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":6},"end":{"line":6,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 414, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":415,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0221729278564ms
Sending response {"id": 415, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":416,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 416, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":78},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> 1"}]}}
Read message 
{"jsonrpc":"2.0","id":417,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":9},"end":{"line":6,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 417, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":418,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 418, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":419,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 419, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":80},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e"}]}}
Read message 
{"jsonrpc":"2.0","id":420,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":6,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0460147857666ms
Sending response {"id": 420, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":81},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1"}]}}
Read message 
{"jsonrpc":"2.0","id":421,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":10},"end":{"line":6,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 421, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":422,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 422, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":423,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 423, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":82},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> expm1"}]}}
Read message 
{"jsonrpc":"2.0","id":424,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":13},"end":{"line":6,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 424, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":425,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 425, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":426,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 426, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":427,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":6,"character":13},"end":{"line":6,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 427, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":87},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1"}]}}
Read message 
{"jsonrpc":"2.0","id":428,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":6,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 428, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":428}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":88},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n"}]}}
Read message 
{"jsonrpc":"2.0","id":429,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 429, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":430,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 430, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":90},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":91},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p"}]}}
Read message 
{"jsonrpc":"2.0","id":431,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":7,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0159740447998ms
Sending response {"id": 431, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":94},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -"}]}}
Read message 
{"jsonrpc":"2.0","id":432,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":7,"character":6},"end":{"line":7,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 432, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":433,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0278949737549ms
Sending response {"id": 433, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":434,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 434, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":96},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> "}]}}
Read message 
{"jsonrpc":"2.0","id":435,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 435, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":436,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 436, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":97},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e"}]}}
Read message 
{"jsonrpc":"2.0","id":437,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":7,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 437, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":98},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":99},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n"}]}}
Read message 
{"jsonrpc":"2.0","id":438,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 438, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":439,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 439, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":100},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n."}]}}
Read message 
{"jsonrpc":"2.0","id":440,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":8,"character":1},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 440, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":440}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":101},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.."}]}}
Read message 
{"jsonrpc":"2.0","id":441,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":8,"character":2},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 441, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":441}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":102},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n..."}]}}
Read message 
{"jsonrpc":"2.0","id":442,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":8,"character":3},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 442, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":442}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":103},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n...."}]}}
Read message 
{"jsonrpc":"2.0","id":443,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":8,"character":4},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 443, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":443}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":104},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n....."}]}}
Read message 
{"jsonrpc":"2.0","id":444,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":8,"character":5},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 444, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":445,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":8,"character":5},"end":{"line":8,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 445, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":446,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 446, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":447,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0739097595215ms
Sending response {"id": 447, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":106},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....CamlinternalFormat\n"}]}}
Read message 
{"jsonrpc":"2.0","id":448,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 448, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":449,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 449, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":107},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....CamlinternalFormat"}]}}
Read message 
{"jsonrpc":"2.0","id":450,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":8,"character":23},"end":{"line":8,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0348091125488ms
Sending response {"id": 450, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":451,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0147819519043ms
Sending response {"id": 451, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":452,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 452, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":108},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n....."}]}}
Read message 
{"jsonrpc":"2.0","id":453,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":8,"character":5},"end":{"line":8,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 453, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":454,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 454, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":455,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 455, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":110},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":456,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 456, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":457,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 457, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":111},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\ne"}]}}
Read message 
{"jsonrpc":"2.0","id":458,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 458, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":113},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\neac"}]}}
Read message 
{"jsonrpc":"2.0","id":459,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 459, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":114},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\neach"}]}}
Read message 
{"jsonrpc":"2.0","id":460,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 460, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":461,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":4},"end":{"line":10,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 461, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":462,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 462, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":463,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 463, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":115},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\neach "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":116},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\neach o"}]}}
Read message 
{"jsonrpc":"2.0","id":464,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 464, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":465,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":6},"end":{"line":10,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 465, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":466,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 466, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":467,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 467, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":122},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":123},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":124},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\nE"}]}}
Read message 
{"jsonrpc":"2.0","id":468,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":9,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 468, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":469,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":9,"character":1},"end":{"line":9,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 469, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":470,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 470, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":471,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 471, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":125},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":126},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":127},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nE"}]}}
Read message 
{"jsonrpc":"2.0","id":472,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 472, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":473,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":1},"end":{"line":10,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 473, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":474,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 474, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":475,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 475, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":128},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEa"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":129},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEac"}]}}
Read message 
{"jsonrpc":"2.0","id":476,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 476, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":130},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach"}]}}
Read message 
{"jsonrpc":"2.0","id":477,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 477, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":131},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":132},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach o"}]}}
Read message 
{"jsonrpc":"2.0","id":478,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 478, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":146},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":147},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p"}]}}
Read message 
{"jsonrpc":"2.0","id":479,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 479, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":148},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1"}]}}
Read message 
{"jsonrpc":"2.0","id":480,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 480, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":150},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":152},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":153},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e"}]}}
Read message 
{"jsonrpc":"2.0","id":481,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.02121925354ms
Sending response {"id": 481, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":156},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 i"}]}}
Read message 
{"jsonrpc":"2.0","id":482,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 482, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":158},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":159},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is a"}]}}
Read message 
{"jsonrpc":"2.0","id":483,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 483, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":484,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":33},"end":{"line":10,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 484, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":485,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 485, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":486,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 486, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":161},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is c"}]}}
Read message 
{"jsonrpc":"2.0","id":487,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 487, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":165},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is calle"}]}}
Read message 
{"jsonrpc":"2.0","id":488,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":37},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 488, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":175},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":176},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":177},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch o"}]}}
Read message 
{"jsonrpc":"2.0","id":489,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 489, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":490,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":49},"end":{"line":10,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00476837158203ms
Sending response {"id": 490, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":491,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 491, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":492,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.028133392334ms
Sending response {"id": 492, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":180},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or c"}]}}
Read message 
{"jsonrpc":"2.0","id":493,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":52},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 493, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":183},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case"}]}}
Read message 
{"jsonrpc":"2.0","id":494,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":55},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0300407409668ms
Sending response {"id": 494, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":495,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":55},"end":{"line":10,"character":55}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 495, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":496,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 496, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":497,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 497, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":185},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case o"}]}}
Read message 
{"jsonrpc":"2.0","id":498,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":57},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 498, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":187},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of "}]}}
Read message 
{"jsonrpc":"2.0","id":499,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 499, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":500,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 500, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":188},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of p"}]}}
Read message 
{"jsonrpc":"2.0","id":501,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 501, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":189},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pa"}]}}
Read message 
{"jsonrpc":"2.0","id":502,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":61},"end":{"line":10,"character":61}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 502, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":503,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0338554382324ms
Sending response {"id": 503, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":504,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 504, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":191},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of patt"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":192},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of patte"}]}}
Read message 
{"jsonrpc":"2.0","id":505,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":64},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 505, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":193},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of patter"}]}}
Read message 
{"jsonrpc":"2.0","id":506,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":65},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 506, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":507,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":65},"end":{"line":10,"character":65}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 507, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":508,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 508, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":509,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 509, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":194},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern"}]}}
Read message 
{"jsonrpc":"2.0","id":510,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":66},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 510, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":196},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern m"}]}}
Read message 
{"jsonrpc":"2.0","id":511,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":68},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 511, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":200},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern mathc"}]}}
Read message 
{"jsonrpc":"2.0","id":512,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":72},"end":{"line":10,"character":72}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 512, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":513,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 513, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":514,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0240802764893ms
Sending response {"id": 514, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":204},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match"}]}}
Read message 
{"jsonrpc":"2.0","id":515,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":72},"end":{"line":10,"character":72}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 515, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":516,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 516, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":517,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 517, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":207},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern matt"}]}}
Read message 
{"jsonrpc":"2.0","id":518,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":71},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 518, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":519,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":71},"end":{"line":10,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Sending response {"id": 519, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":520,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 520, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":521,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 521, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":209},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern matc"}]}}
Read message 
{"jsonrpc":"2.0","id":522,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":10,"character":71},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 522, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":210},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match"}]}}
Read message 
{"jsonrpc":"2.0","id":523,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":72},"end":{"line":10,"character":72}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0371932983398ms
Sending response {"id": 523, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":524,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 524, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":525,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 525, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":211},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match"}]}}
Read message 
{"jsonrpc":"2.0","id":526,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":10,"character":72},"end":{"line":10,"character":72}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 526, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":527,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 527, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":528,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 528, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":212},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\n"}]}}
Read message 
{"jsonrpc":"2.0","id":529,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0331401824951ms
Sending response {"id": 529, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":530,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 530, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":216},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":217},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p"}]}}
Read message 
{"jsonrpc":"2.0","id":531,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 531, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":532,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":5},"end":{"line":11,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 532, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":533,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 533, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":534,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 534, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":218},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p'"}]}}
Read message 
{"jsonrpc":"2.0","id":535,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 535, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":219},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's"}]}}
Read message 
{"jsonrpc":"2.0","id":536,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 536, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":220},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's "}]}}
Read message 
{"jsonrpc":"2.0","id":537,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 537, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":538,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 538, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":221},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's h"}]}}
Read message 
{"jsonrpc":"2.0","id":539,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 539, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":229},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are "}]}}
Read message 
{"jsonrpc":"2.0","id":540,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 540, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":541,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 541, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":230},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are c"}]}}
Read message 
{"jsonrpc":"2.0","id":542,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 542, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":234},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are calle"}]}}
Read message 
{"jsonrpc":"2.0","id":543,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 543, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":235},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called"}]}}
Read message 
{"jsonrpc":"2.0","id":544,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 544, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":236},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":237},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called p"}]}}
Read message 
{"jsonrpc":"2.0","id":545,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 545, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":238},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called pa"}]}}
Read message 
{"jsonrpc":"2.0","id":546,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":26},"end":{"line":11,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 546, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":547,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 547, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":548,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 548, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":240},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patt"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":241},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patte"}]}}
Read message 
{"jsonrpc":"2.0","id":549,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":29},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 549, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":242},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patter"}]}}
Read message 
{"jsonrpc":"2.0","id":550,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 550, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":243},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called pattern"}]}}
Read message 
{"jsonrpc":"2.0","id":551,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 551, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":552,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":31},"end":{"line":11,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 552, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":553,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 553, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":554,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 554, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":244},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns"}]}}
Read message 
{"jsonrpc":"2.0","id":555,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 555, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":556,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":32},"end":{"line":11,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00309944152832ms
Sending response {"id": 556, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":557,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0970363616943ms
Sending response {"id": 557, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":558,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 558, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":245},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns."}]}}
Read message 
{"jsonrpc":"2.0","id":559,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 559, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":560,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":33},"end":{"line":11,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0488758087158ms
Sending response {"id": 560, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":561,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 561, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":562,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 562, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":246},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. "}]}}
Read message 
{"jsonrpc":"2.0","id":563,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 563, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":564,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 564, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":247},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. F"}]}}
Read message 
{"jsonrpc":"2.0","id":565,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 565, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":249},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. For"}]}}
Read message 
{"jsonrpc":"2.0","id":566,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":37},"end":{"line":11,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 566, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":567,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 567, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":568,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 568, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":250},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. Fo"}]}}
Read message 
{"jsonrpc":"2.0","id":569,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":36},"end":{"line":11,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0221729278564ms
Sending response {"id": 569, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":570,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 570, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":571,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 571, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":251},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. F"}]}}
Read message 
{"jsonrpc":"2.0","id":572,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":35},"end":{"line":11,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 572, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":573,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 573, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":574,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 574, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":252},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":253},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A"}]}}
Read message 
{"jsonrpc":"2.0","id":575,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 575, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":254},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":255},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A p"}]}}
Read message 
{"jsonrpc":"2.0","id":576,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":37},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 576, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":256},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pa"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":258},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A patt"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":259},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A patte"}]}}
Read message 
{"jsonrpc":"2.0","id":577,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 577, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":260},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A patter"}]}}
Read message 
{"jsonrpc":"2.0","id":578,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 578, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":261},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern"}]}}
Read message 
{"jsonrpc":"2.0","id":579,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 579, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":264},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern ma"}]}}
Read message 
{"jsonrpc":"2.0","id":580,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":46},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 580, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":265},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may"}]}}
Read message 
{"jsonrpc":"2.0","id":581,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":47},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 581, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":582,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":47},"end":{"line":11,"character":47}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 582, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":583,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 583, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":584,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 584, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":266},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":267},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may b"}]}}
Read message 
{"jsonrpc":"2.0","id":585,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":11,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 585, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":586,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":49},"end":{"line":11,"character":49}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 586, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":587,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0460147857666ms
Sending response {"id": 587, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":588,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 588, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":268},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be"}]}}
Read message 
{"jsonrpc":"2.0","id":589,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":50},"end":{"line":11,"character":50}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 589, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":590,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 590, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":591,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 591, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":269},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be:"}]}}
Read message 
{"jsonrpc":"2.0","id":592,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":11,"character":51},"end":{"line":11,"character":51}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 592, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":593,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 593, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":594,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 594, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":270},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: "}]}}
Read message 
{"jsonrpc":"2.0","id":595,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 595, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":596,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 596, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":272},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  "}]}}
Read message 
{"jsonrpc":"2.0","id":597,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0288486480713ms
Sending response {"id": 597, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":598,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 598, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":273},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":599,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":12,"character":3},"end":{"line":12,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 599, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":600,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 600, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":601,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 601, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":275},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> "}]}}
Read message 
{"jsonrpc":"2.0","id":602,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 602, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":603,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00977516174316ms
Sending response {"id": 603, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":276},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a"}]}}
Read message 
{"jsonrpc":"2.0","id":604,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":12,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 604, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":277},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":278},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a v"}]}}
Read message 
{"jsonrpc":"2.0","id":605,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":12,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0269412994385ms
Sending response {"id": 605, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":286},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable "}]}}
Read message 
{"jsonrpc":"2.0","id":606,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 606, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":607,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 607, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":287},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable n"}]}}
Read message 
{"jsonrpc":"2.0","id":608,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":12,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0178813934326ms
Sending response {"id": 608, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":290},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name"}]}}
Read message 
{"jsonrpc":"2.0","id":609,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":12,"character":20},"end":{"line":12,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0238418579102ms
Sending response {"id": 609, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":610,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 610, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":291},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":611,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0331401824951ms
Sending response {"id": 611, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":612,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 612, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":292},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n    "}]}}
Read message 
{"jsonrpc":"2.0","id":613,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0400543212891ms
Sending response {"id": 613, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":614,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0300407409668ms
Sending response {"id": 614, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":294},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n"}]}}
Read message 
{"jsonrpc":"2.0","id":615,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 615, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":616,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 616, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":295},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> a constant value\n  -> a function call"}]}}
Read message 
{"jsonrpc":"2.0","id":617,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":14,"character":20},"end":{"line":14,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 617, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":618,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 618, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":619,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 619, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":620,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":14,"character":20},"end":{"line":14,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0388622283936ms
Sending response {"id": 620, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":621,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":0},"end":{"line":14,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 621, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":296},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> a constant value\n  -> a function cal"}]}}
Read message 
{"jsonrpc":"2.0","id":622,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":14,"character":19},"end":{"line":14,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 622, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":623,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 623, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":624,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.101089477539ms
Sending response {"id": 624, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":297},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> a constant value\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":298},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> a constant value"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":299},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n"}]}}
Read message 
{"jsonrpc":"2.0","id":625,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 625, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":626,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 626, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":300},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n-"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":302},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":627,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 627, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":628,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 628, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":303},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":629,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":3},"end":{"line":13,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 629, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":630,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 630, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":304},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  ->"}]}}
Read message 
{"jsonrpc":"2.0","id":631,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 631, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":305},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","id":632,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 632, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":633,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 633, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":306},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> T"}]}}
Read message 
{"jsonrpc":"2.0","id":634,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 634, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":312},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The und"}]}}
Read message 
{"jsonrpc":"2.0","id":635,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 635, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":313},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The unde"}]}}
Read message 
{"jsonrpc":"2.0","id":636,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 636, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":637,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":13},"end":{"line":13,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 637, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":638,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 638, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":639,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 639, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":314},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The under"}]}}
Read message 
{"jsonrpc":"2.0","id":640,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0181198120117ms
Sending response {"id": 640, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":641,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":14},"end":{"line":13,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0171661376953ms
Sending response {"id": 641, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":316},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The undersc"}]}}
Read message 
{"jsonrpc":"2.0","id":642,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 642, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":323},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore cha"}]}}
Read message 
{"jsonrpc":"2.0","id":643,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 643, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":644,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":23},"end":{"line":13,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 644, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":645,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 645, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":646,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 646, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":325},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore chara"}]}}
Read message 
{"jsonrpc":"2.0","id":647,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 647, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":326},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore charac"}]}}
Read message 
{"jsonrpc":"2.0","id":648,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 648, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":649,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":26},"end":{"line":13,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 649, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":650,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 650, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":327},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore charact"}]}}
Read message 
{"jsonrpc":"2.0","id":651,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 651, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":652,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 652, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":328},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore characte"}]}}
Read message 
{"jsonrpc":"2.0","id":653,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 653, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":329},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character"}]}}
Read message 
{"jsonrpc":"2.0","id":654,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":29},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0231266021729ms
Sending response {"id": 654, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":655,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":29},"end":{"line":13,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 655, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":656,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 656, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":657,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 657, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":330},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":331},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character w"}]}}
Read message 
{"jsonrpc":"2.0","id":658,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00286102294922ms
Sending response {"id": 658, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":334},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character whic"}]}}
Read message 
{"jsonrpc":"2.0","id":659,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":34},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 659, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":335},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":336},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":337},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which i"}]}}
Read message 
{"jsonrpc":"2.0","id":660,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":37},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 660, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":339},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is "}]}}
Read message 
{"jsonrpc":"2.0","id":661,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 661, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":662,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 662, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":340},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is c"}]}}
Read message 
{"jsonrpc":"2.0","id":663,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 663, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":350},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wild"}]}}
Read message 
{"jsonrpc":"2.0","id":664,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":50},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 664, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":665,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":13,"character":50},"end":{"line":13,"character":50}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 665, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":666,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 666, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":667,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 667, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":351},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildc"}]}}
Read message 
{"jsonrpc":"2.0","id":668,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":51},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 668, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":352},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildca"}]}}
Read message 
{"jsonrpc":"2.0","id":669,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":52},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 669, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":669}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":355},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":670,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 670, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":671,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 671, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":356},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":672,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":14,"character":3},"end":{"line":14,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 672, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":673,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 673, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":674,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 674, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":358},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":359},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> e"}]}}
Read message 
{"jsonrpc":"2.0","id":675,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":14,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 675, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":362},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empt"}]}}
Read message 
{"jsonrpc":"2.0","id":676,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":14,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 676, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":363},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty"}]}}
Read message 
{"jsonrpc":"2.0","id":677,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":14,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 677, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":677}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":369},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":678,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 678, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":679,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 679, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":370},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":680,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":15,"character":3},"end":{"line":15,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 680, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":681,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 681, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":682,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 682, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":371},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  ->"}]}}
Read message 
{"jsonrpc":"2.0","id":683,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":15,"character":4},"end":{"line":15,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0319480895996ms
Sending response {"id": 683, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":684,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 684, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":685,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 685, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":373},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p"}]}}
Read message 
{"jsonrpc":"2.0","id":686,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":15,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 686, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":374},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":379},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p"}]}}
Read message 
{"jsonrpc":"2.0","id":687,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":15,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 687, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":380},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2"}]}}
Read message 
{"jsonrpc":"2.0","id":688,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":15,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 688, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":381},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 "}]}}
Read message 
{"jsonrpc":"2.0","id":689,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 689, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":690,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 690, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":382},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 p"}]}}
Read message 
{"jsonrpc":"2.0","id":691,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":15,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 691, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":391},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending"}]}}
Read message 
{"jsonrpc":"2.0","id":692,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":15,"character":24},"end":{"line":15,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 692, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":693,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 693, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":694,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 694, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":392},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":695,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 695, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":696,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 696, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":394},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  0-"}]}}
Read message 
{"jsonrpc":"2.0","id":697,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":4},"end":{"line":16,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 697, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":698,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 698, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":699,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 699, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":395},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  0"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":396},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":700,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 700, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":701,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 701, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":397},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":702,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":3},"end":{"line":16,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 702, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":703,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 703, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":704,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 704, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":398},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  ->"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":399},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","id":705,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 705, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":706,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 706, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":400},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> []"}]}}
Read message 
{"jsonrpc":"2.0","id":707,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":6},"end":{"line":16,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 707, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":708,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 708, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":709,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 709, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":401},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p]"}]}}
Read message 
{"jsonrpc":"2.0","id":710,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":16,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 710, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":403},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;]"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":404},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;.]"}]}}
Read message 
{"jsonrpc":"2.0","id":711,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":16,"character":10},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 711, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":711}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":405},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;..]"}]}}
Read message 
{"jsonrpc":"2.0","id":712,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":16,"character":11},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 712, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":712}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":406},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...]"}]}}
Read message 
{"jsonrpc":"2.0","id":713,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":16,"character":12},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.028133392334ms
Sending response {"id": 713, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":714,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":12},"end":{"line":16,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 714, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":715,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 715, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":716,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 716, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":717,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":12},"end":{"line":16,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 717, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":407},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;]"}]}}
Read message 
{"jsonrpc":"2.0","id":718,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":13},"end":{"line":16,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 718, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":719,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 719, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":720,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 720, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":408},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;p]"}]}}
Read message 
{"jsonrpc":"2.0","id":721,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":16,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 721, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":722,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":14},"end":{"line":16,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 722, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":723,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 723, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":724,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 724, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":409},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]"}]}}
Read message 
{"jsonrpc":"2.0","id":725,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":15},"end":{"line":16,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 725, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":726,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 726, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":727,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 727, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":728,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":15},"end":{"line":16,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 728, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":729,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":16},"end":{"line":16,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Sending response {"id": 729, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":730,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 730, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":410},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":731,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 731, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":732,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 732, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":411},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\n"}]}}
Read message 
{"jsonrpc":"2.0","id":733,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0238418579102ms
Sending response {"id": 733, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":734,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.018835067749ms
Sending response {"id": 734, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":412},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nB"}]}}
Read message 
{"jsonrpc":"2.0","id":735,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":17,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 735, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":413},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nBN"}]}}
Read message 
{"jsonrpc":"2.0","id":736,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":17,"character":2},"end":{"line":17,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 736, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":737,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 737, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":738,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 738, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":414},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nB"}]}}
Read message 
{"jsonrpc":"2.0","id":739,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":17,"character":1},"end":{"line":17,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 739, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":740,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 740, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":741,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 741, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":415},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nBN"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":417},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":418},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nN"}]}}
Read message 
{"jsonrpc":"2.0","id":742,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":17,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 742, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":420},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNot"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":421},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNote"}]}}
Read message 
{"jsonrpc":"2.0","id":743,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":17,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 743, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":422},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":423},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":424},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":425},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":744,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 744, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":745,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 745, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":426},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  N"}]}}
Read message 
{"jsonrpc":"2.0","id":746,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 746, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":427},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":429},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No v"}]}}
Read message 
{"jsonrpc":"2.0","id":747,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 747, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":445},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":447},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may a"}]}}
Read message 
{"jsonrpc":"2.0","id":748,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0169277191162ms
Sending response {"id": 748, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":452},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":453},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear "}]}}
Read message 
{"jsonrpc":"2.0","id":749,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0112056732178ms
Sending response {"id": 749, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":750,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Sending response {"id": 750, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":454},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear m"}]}}
Read message 
{"jsonrpc":"2.0","id":751,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 751, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":456},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear mor"}]}}
Read message 
{"jsonrpc":"2.0","id":752,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 752, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":459},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more t"}]}}
Read message 
{"jsonrpc":"2.0","id":753,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":36},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0112056732178ms
Sending response {"id": 753, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":754,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":36},"end":{"line":18,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 754, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":755,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 755, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":756,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 756, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":460},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more th"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":462},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than"}]}}
Read message 
{"jsonrpc":"2.0","id":757,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 757, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":463},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":464},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than o"}]}}
Read message 
{"jsonrpc":"2.0","id":758,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 758, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":466},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than onc"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":469},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once i"}]}}
Read message 
{"jsonrpc":"2.0","id":759,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":46},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 759, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":470},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":472},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a"}]}}
Read message 
{"jsonrpc":"2.0","id":760,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 760, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":473},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a "}]}}
Read message 
{"jsonrpc":"2.0","id":761,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 761, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":762,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 762, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":474},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a p"}]}}
Read message 
{"jsonrpc":"2.0","id":763,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":51},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Sending response {"id": 763, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":764,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":51},"end":{"line":18,"character":51}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 764, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":765,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 765, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":475},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pa"}]}}
Read message 
{"jsonrpc":"2.0","id":766,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 766, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":767,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":52},"end":{"line":18,"character":52}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 767, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":768,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 768, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":477},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a patt"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":478},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a patte"}]}}
Read message 
{"jsonrpc":"2.0","id":769,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":55},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 769, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":479},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a patter"}]}}
Read message 
{"jsonrpc":"2.0","id":770,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":56},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0159740447998ms
Sending response {"id": 770, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":480},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern"}]}}
Read message 
{"jsonrpc":"2.0","id":771,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":57},"end":{"line":18,"character":57}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0338554382324ms
Sending response {"id": 771, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":772,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 772, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":481},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern."}]}}
Read message 
{"jsonrpc":"2.0","id":773,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 773, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":774,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 774, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":775,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":58},"end":{"line":18,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 775, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":776,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00977516174316ms
Sending response {"id": 776, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":777,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":58},"end":{"line":18,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0348091125488ms
Sending response {"id": 777, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":483},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. F"}]}}
Read message 
{"jsonrpc":"2.0","id":778,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 778, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":486},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For "}]}}
Read message 
{"jsonrpc":"2.0","id":779,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0448226928711ms
Sending response {"id": 779, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":780,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 780, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":487},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For e"}]}}
Read message 
{"jsonrpc":"2.0","id":781,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":64},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 781, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":490},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For exam"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":492},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For exampl"}]}}
Read message 
{"jsonrpc":"2.0","id":782,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":69},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 782, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":493},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example"}]}}
Read message 
{"jsonrpc":"2.0","id":783,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":70},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 783, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":495},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x"}]}}
Read message 
{"jsonrpc":"2.0","id":784,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":72},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 784, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":496},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":500},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x"}]}}
Read message 
{"jsonrpc":"2.0","id":785,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":77},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 785, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":501},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":502},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x i"}]}}
Read message 
{"jsonrpc":"2.0","id":786,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":79},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00476837158203ms
Sending response {"id": 786, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":504},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":505},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is i"}]}}
Read message 
{"jsonrpc":"2.0","id":787,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":82},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 787, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":788,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":82},"end":{"line":18,"character":82}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 788, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":789,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00214576721191ms
Sending response {"id": 789, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":790,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 790, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":508},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is ille"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":510},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illega"}]}}
Read message 
{"jsonrpc":"2.0","id":791,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":87},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 791, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":511},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal"}]}}
Read message 
{"jsonrpc":"2.0","id":792,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":88},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 792, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":793,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":88},"end":{"line":18,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 793, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":793}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":512},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal."}]}}
Read message 
{"jsonrpc":"2.0","id":794,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":89},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 794, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":795,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":89},"end":{"line":18,"character":89}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 795, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":796,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 796, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":797,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 797, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":513},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal. "}]}}
Read message 
{"jsonrpc":"2.0","id":798,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 798, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":799,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 799, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":515},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal"}]}}
Read message 
{"jsonrpc":"2.0","id":800,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":88},"end":{"line":18,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 800, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":801,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 801, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":802,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 802, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":803,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":88},"end":{"line":18,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 803, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":518},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, b"}]}}
Read message 
{"jsonrpc":"2.0","id":804,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":91},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 804, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":519},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, bu"}]}}
Read message 
{"jsonrpc":"2.0","id":805,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":92},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0200271606445ms
Sending response {"id": 805, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":529},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wild"}]}}
Read message 
{"jsonrpc":"2.0","id":806,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":18,"character":102},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Sending response {"id": 806, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":532},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcar"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":534},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard"}]}}
Read message 
{"jsonrpc":"2.0","id":807,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":106},"end":{"line":18,"character":106}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Sending response {"id": 807, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":808,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 808, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":535},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":809,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 809, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":810,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0300407409668ms
Sending response {"id": 810, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":536},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":811,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 811, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":812,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 812, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":537},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":813,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0298023223877ms
Sending response {"id": 813, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":814,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0247955322266ms
Sending response {"id": 814, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":538},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n"}]}}
Read message 
{"jsonrpc":"2.0","id":815,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 815, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":816,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 816, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":539},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":540},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  m"}]}}
Read message 
{"jsonrpc":"2.0","id":817,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 817, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":542},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may"}]}}
Read message 
{"jsonrpc":"2.0","id":818,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 818, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":543},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":544},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may v"}]}}
Read message 
{"jsonrpc":"2.0","id":819,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 819, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":820,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":7},"end":{"line":19,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 820, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":821,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 821, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":822,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 822, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":545},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may "}]}}
Read message 
{"jsonrpc":"2.0","id":823,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 823, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":824,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 824, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":546},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may i"}]}}
Read message 
{"jsonrpc":"2.0","id":825,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 825, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":826,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":7},"end":{"line":19,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 826, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":827,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 827, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":828,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 828, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":548},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may o"}]}}
Read message 
{"jsonrpc":"2.0","id":829,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 829, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":550},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occ"}]}}
Read message 
{"jsonrpc":"2.0","id":830,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 830, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":551},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occu"}]}}
Read message 
{"jsonrpc":"2.0","id":831,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 831, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":552},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur"}]}}
Read message 
{"jsonrpc":"2.0","id":832,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 832, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":553},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur "}]}}
Read message 
{"jsonrpc":"2.0","id":833,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 833, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":834,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0147819519043ms
Sending response {"id": 834, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":554},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur a"}]}}
Read message 
{"jsonrpc":"2.0","id":835,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 835, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":555},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur an"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":556},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any"}]}}
Read message 
{"jsonrpc":"2.0","id":836,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 836, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":837,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":15},"end":{"line":19,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 837, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":838,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 838, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":839,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 839, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":558},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any n"}]}}
Read message 
{"jsonrpc":"2.0","id":840,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 840, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":559},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any nu"}]}}
Read message 
{"jsonrpc":"2.0","id":841,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 841, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":560},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any num"}]}}
Read message 
{"jsonrpc":"2.0","id":842,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0169277191162ms
Sending response {"id": 842, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":562},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any numbe"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":563},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number"}]}}
Read message 
{"jsonrpc":"2.0","id":843,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 843, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":564},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":565},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number o"}]}}
Read message 
{"jsonrpc":"2.0","id":844,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 844, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":568},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of t"}]}}
Read message 
{"jsonrpc":"2.0","id":845,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":19,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 845, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":573},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\nSyntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times."}]}}
Read message 
{"jsonrpc":"2.0","id":846,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":32},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 846, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":847,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 847, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":848,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 848, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":849,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":32},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 849, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":850,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":18,"character":31},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 850, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":851,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 851, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":852,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":17,"character":5},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 852, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":853,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 853, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":854,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":17,"character":0},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 854, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":855,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 855, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":856,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":16,"character":0},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 856, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":857,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 857, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":858,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":3,"character":0},"end":{"line":19,"character":32}},"context":{"diagnostics":[{"range":{"start":{"line":4,"character":0},"end":{"line":4,"character":6}},"message":"Unbound constructor Syntax","severity":1,"source":"merlin"},{"range":{"start":{"line":5,"character":0},"end":{"line":5,"character":5}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 858, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":859,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 859, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":860,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":4,"character":0},"end":{"line":19,"character":32}},"context":{"diagnostics":[{"range":{"start":{"line":4,"character":0},"end":{"line":4,"character":6}},"message":"Unbound constructor Syntax","severity":1,"source":"merlin"},{"range":{"start":{"line":5,"character":0},"end":{"line":5,"character":5}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 860, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":861,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 861, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":574},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)"}]}}
Read message 
{"jsonrpc":"2.0","id":862,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":4,"character":3},"end":{"line":19,"character":32}},"context":{"diagnostics":[{"range":{"start":{"line":4,"character":0},"end":{"line":4,"character":6}},"message":"Unbound constructor Syntax","severity":1,"source":"merlin"},{"range":{"start":{"line":5,"character":0},"end":{"line":5,"character":5}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0348091125488ms
Sending response {"id": 862, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":863,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 863, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":864,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 864, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":865,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":4,"character":3},"end":{"line":19,"character":32}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 865, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":866,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":13,"character":40}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Sending response {"id": 866, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":867,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":35},"end":{"line":19,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 867, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":868,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 868, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":576},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":869,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 869, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":870,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 870, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":871,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 871, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":872,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 872, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":577},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  D"}]}}
Read message 
{"jsonrpc":"2.0","id":873,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 873, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":578},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dy"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":580},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dyna"}]}}
Read message 
{"jsonrpc":"2.0","id":874,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 874, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":583},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic"}]}}
Read message 
{"jsonrpc":"2.0","id":875,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":9},"end":{"line":21,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 875, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":876,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 876, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":877,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0219345092773ms
Sending response {"id": 877, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":878,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":9},"end":{"line":21,"character":9}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":9}},"message":"Unbound constructor Dynamic","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 878, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":584},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamics"}]}}
Read message 
{"jsonrpc":"2.0","id":879,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 879, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":585},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamicse"}]}}
Read message 
{"jsonrpc":"2.0","id":880,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 880, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":881,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":11},"end":{"line":21,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 881, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":882,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 882, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":883,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 883, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":884,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":11},"end":{"line":21,"character":11}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":11}},"message":"Unbound constructor Dynamicse","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 884, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":586},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamics"}]}}
Read message 
{"jsonrpc":"2.0","id":885,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":10},"end":{"line":21,"character":10}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":11}},"message":"Unbound constructor Dynamicse","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 885, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":886,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 886, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":887,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 887, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":587},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic"}]}}
Read message 
{"jsonrpc":"2.0","id":888,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":9},"end":{"line":21,"character":9}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":11}},"message":"Unbound constructor Dynamicse","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 888, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":889,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 889, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":890,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 890, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":588},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":589},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic s"}]}}
Read message 
{"jsonrpc":"2.0","id":891,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 891, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":592},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic sema"}]}}
Read message 
{"jsonrpc":"2.0","id":892,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":14},"end":{"line":21,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 892, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":893,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 893, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":894,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 894, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":594},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semant"}]}}
Read message 
{"jsonrpc":"2.0","id":895,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 895, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":595},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semanti"}]}}
Read message 
{"jsonrpc":"2.0","id":896,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 896, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":596},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantic"}]}}
Read message 
{"jsonrpc":"2.0","id":897,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 897, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":597},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics"}]}}
Read message 
{"jsonrpc":"2.0","id":898,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":21,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 898, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":600},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":899,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 899, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":900,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 900, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":601},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  m"}]}}
Read message 
{"jsonrpc":"2.0","id":901,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":23,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 901, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":605},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":607},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":613},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [ ]"}]}}
Read message 
{"jsonrpc":"2.0","id":902,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":23,"character":15},"end":{"line":23,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 902, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":903,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 903, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":904,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 904, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":614},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: []"}]}}
Read message 
{"jsonrpc":"2.0","id":905,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":23,"character":14},"end":{"line":23,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 905, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":906,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 906, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":907,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 907, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":616},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] w"}]}}
Read message 
{"jsonrpc":"2.0","id":908,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":23,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 908, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":620},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] withg"}]}}
Read message 
{"jsonrpc":"2.0","id":909,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":23,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 909, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":910,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":23,"character":21},"end":{"line":23,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 910, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":911,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 911, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":912,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 912, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":621},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with"}]}}
Read message 
{"jsonrpc":"2.0","id":913,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":23,"character":20},"end":{"line":23,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 913, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":914,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 914, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":915,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 915, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":622},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":916,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 916, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":917,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 917, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":623},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  \\"}]}}
Read message 
{"jsonrpc":"2.0","id":918,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":24,"character":3},"end":{"line":24,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 918, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":919,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 919, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":920,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 920, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":624},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":625},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  |"}]}}
Read message 
{"jsonrpc":"2.0","id":921,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":24,"character":3},"end":{"line":24,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 921, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":922,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 922, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":923,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 923, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":627},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | []"}]}}
Read message 
{"jsonrpc":"2.0","id":924,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":24,"character":5},"end":{"line":24,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 924, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":925,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 925, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":926,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 926, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":927,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0348091125488ms
Sending response {"id": 927, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":628},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] "}]}}
Read message 
{"jsonrpc":"2.0","id":928,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 928, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":929,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.018835067749ms
Sending response {"id": 929, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":629},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] _"}]}}
Read message 
{"jsonrpc":"2.0","id":930,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":24,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 930, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":931,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":24,"character":8},"end":{"line":24,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.028133392334ms
Sending response {"id": 931, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":932,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 932, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":933,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0290870666504ms
Sending response {"id": 933, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":631},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -"}]}}
Read message 
{"jsonrpc":"2.0","id":934,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":24,"character":8},"end":{"line":24,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 934, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":935,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 935, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":936,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 936, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":634},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> f"}]}}
Read message 
{"jsonrpc":"2.0","id":937,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":24,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 937, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":639},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false"}]}}
Read message 
{"jsonrpc":"2.0","id":938,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":24,"character":15},"end":{"line":24,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 938, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":640},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":939,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 939, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":940,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 940, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":642},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | "}]}}
Read message 
{"jsonrpc":"2.0","id":941,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 941, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":942,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 942, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":643},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h"}]}}
Read message 
{"jsonrpc":"2.0","id":943,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":25,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 943, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":646},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h ::"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":647},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: "}]}}
Read message 
{"jsonrpc":"2.0","id":944,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 944, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":945,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 945, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":648},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t"}]}}
Read message 
{"jsonrpc":"2.0","id":946,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":25,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0319480895996ms
Sending response {"id": 946, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":649},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":650},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -"}]}}
Read message 
{"jsonrpc":"2.0","id":947,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":25,"character":12},"end":{"line":25,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 947, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":948,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 948, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":949,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 949, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":652},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> "}]}}
Read message 
{"jsonrpc":"2.0","id":950,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 950, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":951,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 951, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":653},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h"}]}}
Read message 
{"jsonrpc":"2.0","id":952,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":25,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 952, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":657},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1"}]}}
Read message 
{"jsonrpc":"2.0","id":953,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":25,"character":19},"end":{"line":25,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Sending response {"id": 953, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":954,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 954, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":955,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 955, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":658},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":661},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && "}]}}
Read message 
{"jsonrpc":"2.0","id":956,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 956, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":957,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 957, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":662},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t"}]}}
Read message 
{"jsonrpc":"2.0","id":958,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":25,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 958, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":666},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []"}]}}
Read message 
{"jsonrpc":"2.0","id":959,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":25,"character":28},"end":{"line":25,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 959, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":960,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 960, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":961,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 961, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":962,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0331401824951ms
Sending response {"id": 962, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":963,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":25,"character":29},"end":{"line":25,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 963, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":667},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":964,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 964, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":965,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 965, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":668},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":966,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 966, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":967,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0779628753662ms
Sending response {"id": 967, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":669},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":968,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":27,"character":3},"end":{"line":27,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 968, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":969,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 969, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":970,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 970, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":671},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","id":971,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 971, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":972,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 972, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":673},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 "}]}}
Read message 
{"jsonrpc":"2.0","id":973,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 973, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":974,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 974, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":677},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: []"}]}}
Read message 
{"jsonrpc":"2.0","id":975,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":27,"character":11},"end":{"line":27,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 975, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":976,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 976, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":977,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 977, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":678},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":680},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] ui"}]}}
Read message 
{"jsonrpc":"2.0","id":978,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 978, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":979,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":27,"character":15},"end":{"line":27,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 979, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":980,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 980, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":981,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 981, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":681},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] u"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":682},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] us"}]}}
Read message 
{"jsonrpc":"2.0","id":982,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 982, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":684},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":685},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] i"}]}}
Read message 
{"jsonrpc":"2.0","id":983,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 983, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":690},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is alr"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":691},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is alre"}]}}
Read message 
{"jsonrpc":"2.0","id":984,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 984, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":692},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is alrea"}]}}
Read message 
{"jsonrpc":"2.0","id":985,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Sending response {"id": 985, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":694},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":696},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a"}]}}
Read message 
{"jsonrpc":"2.0","id":986,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 986, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":697},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a "}]}}
Read message 
{"jsonrpc":"2.0","id":987,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 987, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":988,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 988, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":698},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a v"}]}}
Read message 
{"jsonrpc":"2.0","id":989,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 989, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":699},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a va"}]}}
Read message 
{"jsonrpc":"2.0","id":990,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":27,"character":28},"end":{"line":27,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 990, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":991,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 991, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":992,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 992, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":700},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a val"}]}}
Read message 
{"jsonrpc":"2.0","id":993,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":27,"character":29},"end":{"line":27,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 993, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":994,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 994, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":995,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 995, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":702},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value"}]}}
Read message 
{"jsonrpc":"2.0","id":996,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":27,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 996, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":997,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":27,"character":31},"end":{"line":27,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 997, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":998,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 998, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":999,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 999, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":703},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1000,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 1000, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1001,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0288486480713ms
Sending response {"id": 1001, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":704},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":1002,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":28,"character":3},"end":{"line":28,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1002, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1003,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00476837158203ms
Sending response {"id": 1003, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1004,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 1004, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":705},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  ->"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":706},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","id":1005,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1005, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1006,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1006, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":707},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> []"}]}}
Read message 
{"jsonrpc":"2.0","id":1007,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":28,"character":6},"end":{"line":28,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1007, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1008,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1008, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1009,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1009, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1010,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 1010, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":708},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] "}]}}
Read message 
{"jsonrpc":"2.0","id":1011,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1011, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":709},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] d"}]}}
Read message 
{"jsonrpc":"2.0","id":1012,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":28,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1012, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":712},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does"}]}}
Read message 
{"jsonrpc":"2.0","id":1013,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":28,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1013, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":713},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":714},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does n"}]}}
Read message 
{"jsonrpc":"2.0","id":1014,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":28,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1014, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":718},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not m"}]}}
Read message 
{"jsonrpc":"2.0","id":1015,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":28,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1015, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":720},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not mat"}]}}
Read message 
{"jsonrpc":"2.0","id":1016,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":28,"character":20},"end":{"line":28,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1016, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1017,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1017, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1018,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1018, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":724},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match []"}]}}
Read message 
{"jsonrpc":"2.0","id":1019,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":28,"character":24},"end":{"line":28,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1019, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1020,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1020, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1021,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1021, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":730},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":731},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []"}]}}
Read message 
{"jsonrpc":"2.0","id":1022,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":28,"character":29},"end":{"line":28,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1022, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1023,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1023, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1024,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00286102294922ms
Sending response {"id": 1024, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":732},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1025,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 1025, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1026,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1026, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":733},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":1027,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":3},"end":{"line":29,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1027, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1028,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1028, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1029,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 1029, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":735},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","id":1030,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 1030, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1031,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1031, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":736},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h"}]}}
Read message 
{"jsonrpc":"2.0","id":1032,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1032, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":737},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":740},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: "}]}}
Read message 
{"jsonrpc":"2.0","id":1033,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1033, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1034,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1034, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":741},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t"}]}}
Read message 
{"jsonrpc":"2.0","id":1035,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1035, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":747},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does "}]}}
Read message 
{"jsonrpc":"2.0","id":1036,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1036, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1037,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1037, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":748},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does m"}]}}
Read message 
{"jsonrpc":"2.0","id":1038,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1038, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":750},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does mat"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":752},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":754},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1"}]}}
Read message 
{"jsonrpc":"2.0","id":1039,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":24},"end":{"line":29,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 1039, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1040,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 1040, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1041,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 1041, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":759},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: []"}]}}
Read message 
{"jsonrpc":"2.0","id":1042,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":29},"end":{"line":29,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0300407409668ms
Sending response {"id": 1042, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1043,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1043, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1044,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1044, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":761},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] a"}]}}
Read message 
{"jsonrpc":"2.0","id":1045,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1045, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":764},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":765},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and p"}]}}
Read message 
{"jsonrpc":"2.0","id":1046,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":36},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1046, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":768},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and prod"}]}}
Read message 
{"jsonrpc":"2.0","id":1047,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1047, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":769},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produ"}]}}
Read message 
{"jsonrpc":"2.0","id":1048,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1048, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":770},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produc"}]}}
Read message 
{"jsonrpc":"2.0","id":1049,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1049, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":771},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produce"}]}}
Read message 
{"jsonrpc":"2.0","id":1050,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1050, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":772},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces"}]}}
Read message 
{"jsonrpc":"2.0","id":1051,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1051, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":774},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces v"}]}}
Read message 
{"jsonrpc":"2.0","id":1052,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1052, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":777},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces vari"}]}}
Read message 
{"jsonrpc":"2.0","id":1053,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":48},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1053, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1054,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":48},"end":{"line":29,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1054, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1055,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1055, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1056,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1056, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":778},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces varia"}]}}
Read message 
{"jsonrpc":"2.0","id":1057,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1057, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":779},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variab"}]}}
Read message 
{"jsonrpc":"2.0","id":1058,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":50},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1058, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1059,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":50},"end":{"line":29,"character":50}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 1059, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1060,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1060, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1061,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1061, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":780},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variabl"}]}}
Read message 
{"jsonrpc":"2.0","id":1062,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":51},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1062, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":782},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":783},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable b"}]}}
Read message 
{"jsonrpc":"2.0","id":1063,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":54},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1063, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":786},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bind"}]}}
Read message 
{"jsonrpc":"2.0","id":1064,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":57},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Sending response {"id": 1064, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":789},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable binding"}]}}
Read message 
{"jsonrpc":"2.0","id":1065,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":60},"end":{"line":29,"character":60}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 1065, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1066,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1066, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1067,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1067, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":790},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings"}]}}
Read message 
{"jsonrpc":"2.0","id":1068,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":61},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1068, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":791},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings "}]}}
Read message 
{"jsonrpc":"2.0","id":1069,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1069, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1070,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1070, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":792},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {}"}]}}
Read message 
{"jsonrpc":"2.0","id":1071,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":63},"end":{"line":29,"character":63}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1071, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1072,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1072, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1073,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1073, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":793},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h}"}]}}
Read message 
{"jsonrpc":"2.0","id":1074,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":64},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1074, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":795},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -}"}]}}
Read message 
{"jsonrpc":"2.0","id":1075,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":66},"end":{"line":29,"character":66}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1075, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1076,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.028133392334ms
Sending response {"id": 1076, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1077,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1077, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":797},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> }"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":798},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1}"}]}}
Read message 
{"jsonrpc":"2.0","id":1078,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":69},"end":{"line":29,"character":69}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1078, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1079,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1079, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1080,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0321865081787ms
Sending response {"id": 1080, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":799},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1,}"}]}}
Read message 
{"jsonrpc":"2.0","id":1081,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":70},"end":{"line":29,"character":70}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1081, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":800},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, }"}]}}
Read message 
{"jsonrpc":"2.0","id":1082,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":71},"end":{"line":29,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1082, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1083,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1083, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1084,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 1084, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1085,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":71},"end":{"line":29,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1085, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":801},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t}"}]}}
Read message 
{"jsonrpc":"2.0","id":1086,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":72},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1086, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":802},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t }"}]}}
Read message 
{"jsonrpc":"2.0","id":1087,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":73},"end":{"line":29,"character":73}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00476837158203ms
Sending response {"id": 1087, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1088,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1088, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1089,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1089, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":803},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -}"}]}}
Read message 
{"jsonrpc":"2.0","id":1090,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":74},"end":{"line":29,"character":74}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1090, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1091,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1091, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1092,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1092, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":806},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []}"}]}}
Read message 
{"jsonrpc":"2.0","id":1093,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":77},"end":{"line":29,"character":77}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1093, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1094,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1094, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1095,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1095, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1096,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 1096, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":807},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> [] }"}]}}
Read message 
{"jsonrpc":"2.0","id":1097,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":79},"end":{"line":29,"character":79}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1097, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1098,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1098, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1099,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1099, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":808},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []}"}]}}
Read message 
{"jsonrpc":"2.0","id":1100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":78},"end":{"line":29,"character":78}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 1100, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1101,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1101, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1102,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1102, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":809},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> [] }"}]}}
Read message 
{"jsonrpc":"2.0","id":1103,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":79},"end":{"line":29,"character":79}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 1103, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1104,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0269412994385ms
Sending response {"id": 1104, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1105,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1105, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":810},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []}"}]}}
Read message 
{"jsonrpc":"2.0","id":1106,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0231266021729ms
Sending response {"id": 1106, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":811},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":812},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} b"}]}}
Read message 
{"jsonrpc":"2.0","id":1107,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":81},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1107, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":814},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} bec"}]}}
Read message 
{"jsonrpc":"2.0","id":1108,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":83},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1108, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":815},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} beca"}]}}
Read message 
{"jsonrpc":"2.0","id":1109,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":84},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1109, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":816},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} becau"}]}}
Read message 
{"jsonrpc":"2.0","id":1110,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":85},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1110, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":817},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} becaus"}]}}
Read message 
{"jsonrpc":"2.0","id":1111,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":29,"character":86},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1111, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":818},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because"}]}}
Read message 
{"jsonrpc":"2.0","id":1112,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":29,"character":87},"end":{"line":29,"character":87}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1112, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1113,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1113, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1114,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1114, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":819},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because "}]}}
Read message 
{"jsonrpc":"2.0","id":1115,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1115, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1116,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1116, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":822},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":824},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    "}]}}
Read message 
{"jsonrpc":"2.0","id":1117,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 1117, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1118,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1118, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":825},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    -"}]}}
Read message 
{"jsonrpc":"2.0","id":1119,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":30,"character":5},"end":{"line":30,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1119, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1120,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1120, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1121,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1121, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":826},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - "}]}}
Read message 
{"jsonrpc":"2.0","id":1122,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0338554382324ms
Sending response {"id": 1122, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1123,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1123, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":827},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h"}]}}
Read message 
{"jsonrpc":"2.0","id":1124,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0400543212891ms
Sending response {"id": 1124, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":831},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h mat"}]}}
Read message 
{"jsonrpc":"2.0","id":1125,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1125, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":834},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matche"}]}}
Read message 
{"jsonrpc":"2.0","id":1126,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1126, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":835},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches"}]}}
Read message 
{"jsonrpc":"2.0","id":1127,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1127, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":839},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 a"}]}}
Read message 
{"jsonrpc":"2.0","id":1128,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1128, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":842},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":843},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and p"}]}}
Read message 
{"jsonrpc":"2.0","id":1129,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1129, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":846},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and prod"}]}}
Read message 
{"jsonrpc":"2.0","id":1130,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 1130, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":861},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variab"}]}}
Read message 
{"jsonrpc":"2.0","id":1131,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1131, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":865},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable b"}]}}
Read message 
{"jsonrpc":"2.0","id":1132,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1132, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":868},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bind"}]}}
Read message 
{"jsonrpc":"2.0","id":1133,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":48},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00286102294922ms
Sending response {"id": 1133, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1134,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":30,"character":48},"end":{"line":30,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 1134, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1135,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1135, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1136,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1136, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":869},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bin"}]}}
Read message 
{"jsonrpc":"2.0","id":1137,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":30,"character":47},"end":{"line":30,"character":47}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 1137, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1138,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 1138, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1139,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1139, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":870},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bind"}]}}
Read message 
{"jsonrpc":"2.0","id":1140,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":48},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1140, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":873},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable binding"}]}}
Read message 
{"jsonrpc":"2.0","id":1141,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":30,"character":51},"end":{"line":30,"character":51}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Sending response {"id": 1141, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1142,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1142, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1143,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1143, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":874},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings"}]}}
Read message 
{"jsonrpc":"2.0","id":1144,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":52},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1144, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":875},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings "}]}}
Read message 
{"jsonrpc":"2.0","id":1145,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1145, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1146,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1146, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":876},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h"}]}}
Read message 
{"jsonrpc":"2.0","id":1147,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":30,"character":54},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1147, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":878},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -"}]}}
Read message 
{"jsonrpc":"2.0","id":1148,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":30,"character":56},"end":{"line":30,"character":56}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1148, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1149,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1149, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1150,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1150, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":882},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    "}]}}
Read message 
{"jsonrpc":"2.0","id":1151,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1151, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1152,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1152, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":884},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - "}]}}
Read message 
{"jsonrpc":"2.0","id":1153,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1153, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1154,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1154, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":885},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t"}]}}
Read message 
{"jsonrpc":"2.0","id":1155,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1155, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":887},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t m"}]}}
Read message 
{"jsonrpc":"2.0","id":1156,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1156, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":890},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matr"}]}}
Read message 
{"jsonrpc":"2.0","id":1157,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":12},"end":{"line":31,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 1157, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1158,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1158, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1159,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 1159, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":892},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matc"}]}}
Read message 
{"jsonrpc":"2.0","id":1160,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1160, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":896},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":897},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches []"}]}}
Read message 
{"jsonrpc":"2.0","id":1161,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":17},"end":{"line":31,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1161, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1162,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1162, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1163,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1163, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":899},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] a"}]}}
Read message 
{"jsonrpc":"2.0","id":1164,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1164, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":902},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":903},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and p"}]}}
Read message 
{"jsonrpc":"2.0","id":1165,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1165, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":904},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and pr"}]}}
Read message 
{"jsonrpc":"2.0","id":1166,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":25},"end":{"line":31,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1166, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1167,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1167, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1168,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0231266021729ms
Sending response {"id": 1168, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":905},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and pro"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":906},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and prod"}]}}
Read message 
{"jsonrpc":"2.0","id":1169,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1169, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":907},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produ"}]}}
Read message 
{"jsonrpc":"2.0","id":1170,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Sending response {"id": 1170, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":908},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produc"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":909},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produce"}]}}
Read message 
{"jsonrpc":"2.0","id":1171,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1171, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":910},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces"}]}}
Read message 
{"jsonrpc":"2.0","id":1172,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1172, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":911},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":912},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces t"}]}}
Read message 
{"jsonrpc":"2.0","id":1173,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1173, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":914},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the"}]}}
Read message 
{"jsonrpc":"2.0","id":1174,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1174, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":916},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the v"}]}}
Read message 
{"jsonrpc":"2.0","id":1175,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":37},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1175, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":919},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the vari"}]}}
Read message 
{"jsonrpc":"2.0","id":1176,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1176, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1177,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":40},"end":{"line":31,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1177, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1178,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1178, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1179,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 1179, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":920},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the varia"}]}}
Read message 
{"jsonrpc":"2.0","id":1180,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1180, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":921},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variab"}]}}
Read message 
{"jsonrpc":"2.0","id":1181,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 1181, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":932},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding "}]}}
Read message 
{"jsonrpc":"2.0","id":1182,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1182, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1183,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1183, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":933},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t"}]}}
Read message 
{"jsonrpc":"2.0","id":1184,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":54},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1184, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":935},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -"}]}}
Read message 
{"jsonrpc":"2.0","id":1185,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":56},"end":{"line":31,"character":56}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1185, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1186,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1186, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1187,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1187, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":938},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []"}]}}
Read message 
{"jsonrpc":"2.0","id":1188,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":59},"end":{"line":31,"character":59}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1188, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1189,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 1189, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1190,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 1190, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1191,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":60},"end":{"line":31,"character":60}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1191, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1192,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1192, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":939},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []."}]}}
Read message 
{"jsonrpc":"2.0","id":1193,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":31,"character":61},"context":{"triggerKind":2,"triggerCharacter":"."}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1193, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":941},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> [].CamlinternalFormat\n    "}]}}
Read message 
{"jsonrpc":"2.0","id":1194,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0112056732178ms
Sending response {"id": 1194, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1195,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 1195, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":943},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []."}]}}
Read message 
{"jsonrpc":"2.0","id":1196,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":31,"character":61},"end":{"line":31,"character":61}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Sending response {"id": 1196, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1197,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 1197, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1198,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1198, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":944},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":945},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n    "}]}}
Read message 
{"jsonrpc":"2.0","id":1199,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0271797180176ms
Sending response {"id": 1199, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1200,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 1200, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":946},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1201,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0288486480713ms
Sending response {"id": 1201, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1202,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 1202, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":947},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":1203,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":3},"end":{"line":32,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1203, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1204,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 1204, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1205,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1205, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":948},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  ->"}]}}
Read message 
{"jsonrpc":"2.0","id":1206,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":4},"end":{"line":32,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1206, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1207,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1207, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1208,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 1208, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":949},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":1209,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":3},"end":{"line":32,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1209, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1210,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1210, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1211,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00476837158203ms
Sending response {"id": 1211, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1212,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":3},"end":{"line":32,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 1212, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":952},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> S"}]}}
Read message 
{"jsonrpc":"2.0","id":1213,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1213, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":954},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Sub"}]}}
Read message 
{"jsonrpc":"2.0","id":1214,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1214, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":955},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Subs"}]}}
Read message 
{"jsonrpc":"2.0","id":1215,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1215, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":957},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substi"}]}}
Read message 
{"jsonrpc":"2.0","id":1216,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":11},"end":{"line":32,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1216, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1217,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1217, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1218,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1218, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":958},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substit"}]}}
Read message 
{"jsonrpc":"2.0","id":1219,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1219, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":959},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substitu"}]}}
Read message 
{"jsonrpc":"2.0","id":1220,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0200271606445ms
Sending response {"id": 1220, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1221,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":13},"end":{"line":32,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1221, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1222,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 1222, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1223,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1223, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":960},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substitui"}]}}
Read message 
{"jsonrpc":"2.0","id":1224,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1224, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":961},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituin"}]}}
Read message 
{"jsonrpc":"2.0","id":1225,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1225, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":963},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituing "}]}}
Read message 
{"jsonrpc":"2.0","id":1226,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1226, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1227,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1227, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":967},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substitu"}]}}
Read message 
{"jsonrpc":"2.0","id":1228,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":13},"end":{"line":32,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0371932983398ms
Sending response {"id": 1228, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1229,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1229, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1230,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1230, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1231,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":13},"end":{"line":32,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1231, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":968},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substitut"}]}}
Read message 
{"jsonrpc":"2.0","id":1232,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0300407409668ms
Sending response {"id": 1232, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":970},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituton"}]}}
Read message 
{"jsonrpc":"2.0","id":1233,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":16},"end":{"line":32,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1233, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1234,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1234, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1235,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1235, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1236,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":16},"end":{"line":32,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0438690185547ms
Sending response {"id": 1236, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":971},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituto"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":972},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substitut"}]}}
Read message 
{"jsonrpc":"2.0","id":1237,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":14},"end":{"line":32,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0460147857666ms
Sending response {"id": 1237, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1238,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1238, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1239,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1239, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":973},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituti"}]}}
Read message 
{"jsonrpc":"2.0","id":1240,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1240, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":974},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substitutin"}]}}
Read message 
{"jsonrpc":"2.0","id":1241,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1241, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":976},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting "}]}}
Read message 
{"jsonrpc":"2.0","id":1242,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1242, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1243,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1243, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":977},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {}"}]}}
Read message 
{"jsonrpc":"2.0","id":1244,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":19},"end":{"line":32,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1244, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1245,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1245, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1246,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00286102294922ms
Sending response {"id": 1246, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":978},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h}"}]}}
Read message 
{"jsonrpc":"2.0","id":1247,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1247, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1248,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":20},"end":{"line":32,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1248, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1249,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 1249, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1250,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 1250, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":979},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h-}"}]}}
Read message 
{"jsonrpc":"2.0","id":1251,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":21},"end":{"line":32,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1251, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1252,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1252, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1253,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1253, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":980},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->}"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":981},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1}"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":982},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1 }"}]}}
Read message 
{"jsonrpc":"2.0","id":1254,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":24},"end":{"line":32,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1254, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1255,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1255, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1256,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 1256, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":983},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1}"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":985},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, }"}]}}
Read message 
{"jsonrpc":"2.0","id":1257,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":25},"end":{"line":32,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1257, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":986},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t}"}]}}
Read message 
{"jsonrpc":"2.0","id":1258,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 1258, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":988},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -}"}]}}
Read message 
{"jsonrpc":"2.0","id":1259,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":28},"end":{"line":32,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1259, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1260,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1260, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1261,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1261, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":991},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []}"}]}}
Read message 
{"jsonrpc":"2.0","id":1262,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":31},"end":{"line":32,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1262, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1263,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1263, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1264,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 1264, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1265,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1265, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1266,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":33},"end":{"line":32,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1266, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1267,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 1267, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":992},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} "}]}}
Read message 
{"jsonrpc":"2.0","id":1268,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1268, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1269,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1269, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":993},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} i"}]}}
Read message 
{"jsonrpc":"2.0","id":1270,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1270, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":999},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside "}]}}
Read message 
{"jsonrpc":"2.0","id":1271,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 1271, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1272,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1272, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1000},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h"}]}}
Read message 
{"jsonrpc":"2.0","id":1273,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1273, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1002},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h ="}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1004},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1008},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && "}]}}
Read message 
{"jsonrpc":"2.0","id":1274,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1274, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1275,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1275, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1009},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t"}]}}
Read message 
{"jsonrpc":"2.0","id":1276,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":51},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1276, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1013},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = []"}]}}
Read message 
{"jsonrpc":"2.0","id":1277,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":55},"end":{"line":32,"character":55}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 1277, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1278,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 1278, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1279,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 1279, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1280,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 1280, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1281,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":56},"end":{"line":32,"character":56}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Sending response {"id": 1281, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1015},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] p"}]}}
Read message 
{"jsonrpc":"2.0","id":1282,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1282, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1018},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] prod"}]}}
Read message 
{"jsonrpc":"2.0","id":1283,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":61},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1283, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1019},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produ"}]}}
Read message 
{"jsonrpc":"2.0","id":1284,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":62},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1284, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1020},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produc"}]}}
Read message 
{"jsonrpc":"2.0","id":1285,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":63},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0200271606445ms
Sending response {"id": 1285, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1022},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1023},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces "}]}}
Read message 
{"jsonrpc":"2.0","id":1286,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 1286, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1287,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1287, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1024},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a"}]}}
Read message 
{"jsonrpc":"2.0","id":1288,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":67},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1288, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1026},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a n"}]}}
Read message 
{"jsonrpc":"2.0","id":1289,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":69},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1289, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1030},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new e"}]}}
Read message 
{"jsonrpc":"2.0","id":1290,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":73},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1290, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1033},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expr"}]}}
Read message 
{"jsonrpc":"2.0","id":1291,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":76},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1291, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1034},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expre"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1036},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new express"}]}}
Read message 
{"jsonrpc":"2.0","id":1292,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":79},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0169277191162ms
Sending response {"id": 1292, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1038},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expressio"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1039},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression"}]}}
Read message 
{"jsonrpc":"2.0","id":1293,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":82},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1293, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1045},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1"}]}}
Read message 
{"jsonrpc":"2.0","id":1294,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":88},"end":{"line":32,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1294, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1295,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1295, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1296,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1296, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1297,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":88},"end":{"line":32,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 1297, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1046},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1&"}]}}
Read message 
{"jsonrpc":"2.0","id":1298,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":89},"end":{"line":32,"character":89}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1298, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1299,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1299, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1300,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1300, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1052},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && []"}]}}
Read message 
{"jsonrpc":"2.0","id":1301,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":93},"end":{"line":32,"character":93}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1301, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1302,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1302, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1303,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1303, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1055},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1056},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []"}]}}
Read message 
{"jsonrpc":"2.0","id":1304,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1304, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1305,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":32,"character":99},"end":{"line":32,"character":99}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1305, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1306,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1306, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1057},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1307,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 1307, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1308,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1308, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1058},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":1309,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":3},"end":{"line":33,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1309, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1310,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1310, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1311,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 1311, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1060},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1061},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> E"}]}}
Read message 
{"jsonrpc":"2.0","id":1312,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 1312, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1062},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Ev"}]}}
Read message 
{"jsonrpc":"2.0","id":1313,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1313, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1063},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Eva"}]}}
Read message 
{"jsonrpc":"2.0","id":1314,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1314, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1064},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Eval"}]}}
Read message 
{"jsonrpc":"2.0","id":1315,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1315, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1066},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evalua"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1068},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluati"}]}}
Read message 
{"jsonrpc":"2.0","id":1316,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1316, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1069},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluatin"}]}}
Read message 
{"jsonrpc":"2.0","id":1317,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1317, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1070},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating"}]}}
Read message 
{"jsonrpc":"2.0","id":1318,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1318, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1076},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1"}]}}
Read message 
{"jsonrpc":"2.0","id":1319,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":21},"end":{"line":33,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1319, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1320,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 1320, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1321,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 1321, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1080},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && "}]}}
Read message 
{"jsonrpc":"2.0","id":1322,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 1322, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1323,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1323, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1081},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && []"}]}}
Read message 
{"jsonrpc":"2.0","id":1324,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":26},"end":{"line":33,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1324, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1325,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1325, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1326,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1326, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1083},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] ="}]}}
Read message 
{"jsonrpc":"2.0","id":1327,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":29},"end":{"line":33,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1327, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1328,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1328, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1329,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1329, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1085},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = []"}]}}
Read message 
{"jsonrpc":"2.0","id":1330,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":31},"end":{"line":33,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 1330, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1331,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1331, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1332,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1332, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1086},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1087},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] y"}]}}
Read message 
{"jsonrpc":"2.0","id":1333,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":34},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1333, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1088},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yi"}]}}
Read message 
{"jsonrpc":"2.0","id":1334,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 1334, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1093},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields "}]}}
Read message 
{"jsonrpc":"2.0","id":1335,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0288486480713ms
Sending response {"id": 1335, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1336,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0288486480713ms
Sending response {"id": 1336, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1094},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields t"}]}}
Read message 
{"jsonrpc":"2.0","id":1337,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1337, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1098},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the v"}]}}
Read message 
{"jsonrpc":"2.0","id":1338,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1338, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1100},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the val"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1102},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value"}]}}
Read message 
{"jsonrpc":"2.0","id":1339,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0321865081787ms
Sending response {"id": 1339, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1109},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1110},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. W"}]}}
Read message 
{"jsonrpc":"2.0","id":1340,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":57},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1340, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1111},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We"}]}}
Read message 
{"jsonrpc":"2.0","id":1341,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":58},"end":{"line":33,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1341, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1342,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1342, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1343,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1343, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1112},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We "}]}}
Read message 
{"jsonrpc":"2.0","id":1344,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 1344, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1345,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1345, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1113},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We o"}]}}
Read message 
{"jsonrpc":"2.0","id":1346,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1346, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1347,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":60},"end":{"line":33,"character":60}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1347, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1348,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1348, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1114},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We om"}]}}
Read message 
{"jsonrpc":"2.0","id":1349,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1349, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1350,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":61},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00286102294922ms
Sending response {"id": 1350, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1115},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omi"}]}}
Read message 
{"jsonrpc":"2.0","id":1351,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":62},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1351, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1116},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit"}]}}
Read message 
{"jsonrpc":"2.0","id":1352,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":63},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0338554382324ms
Sending response {"id": 1352, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1133},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justificatio"}]}}
Read message 
{"jsonrpc":"2.0","id":1353,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":80},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.06103515625ms
Sending response {"id": 1353, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1136},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification f"}]}}
Read message 
{"jsonrpc":"2.0","id":1354,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":83},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1354, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1137},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification fo"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1139},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification fo t"}]}}
Read message 
{"jsonrpc":"2.0","id":1355,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":86},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1355, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1356,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":33,"character":86},"end":{"line":33,"character":86}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0300407409668ms
Sending response {"id": 1356, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1357,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1357, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1358,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1358, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1142},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for"}]}}
Read message 
{"jsonrpc":"2.0","id":1359,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":85},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1359, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1148},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that "}]}}
Read message 
{"jsonrpc":"2.0","id":1360,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1360, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1361,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1361, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1149},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that f"}]}}
Read message 
{"jsonrpc":"2.0","id":1362,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":92},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Sending response {"id": 1362, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1151},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fac"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1152},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact"}]}}
Read message 
{"jsonrpc":"2.0","id":1363,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":95},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1363, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1153},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1154},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact h"}]}}
Read message 
{"jsonrpc":"2.0","id":1364,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":97},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1364, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1155},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact he"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1156},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact her"}]}}
Read message 
{"jsonrpc":"2.0","id":1365,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":99},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1365, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1157},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here"}]}}
Read message 
{"jsonrpc":"2.0","id":1366,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":100},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1366, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1159},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1160},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, b"}]}}
Read message 
{"jsonrpc":"2.0","id":1367,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":103},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1367, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1167},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it w"}]}}
Read message 
{"jsonrpc":"2.0","id":1368,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":110},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0278949737549ms
Sending response {"id": 1368, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1169},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it f"}]}}
Read message 
{"jsonrpc":"2.0","id":1369,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":110},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1369, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1170},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it fo"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1172},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it foll"}]}}
Read message 
{"jsonrpc":"2.0","id":1370,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":113},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1370, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1174},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follow"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1175},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows"}]}}
Read message 
{"jsonrpc":"2.0","id":1371,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":33,"character":116},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1371, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1176},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1372,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 1372, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1373,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1373, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1177},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  f"}]}}
Read message 
{"jsonrpc":"2.0","id":1374,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0288486480713ms
Sending response {"id": 1374, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1180},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  form"}]}}
Read message 
{"jsonrpc":"2.0","id":1375,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":6},"end":{"line":34,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1375, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1376,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1376, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1377,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1377, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1186},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1187},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from "}]}}
Read message 
{"jsonrpc":"2.0","id":1378,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1378, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1379,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1379, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1188},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from o"}]}}
Read message 
{"jsonrpc":"2.0","id":1380,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1380, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1192},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other"}]}}
Read message 
{"jsonrpc":"2.0","id":1381,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1381, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1193},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other "}]}}
Read message 
{"jsonrpc":"2.0","id":1382,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1382, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1383,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1383, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1194},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other e"}]}}
Read message 
{"jsonrpc":"2.0","id":1384,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1384, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1195},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other ev"}]}}
Read message 
{"jsonrpc":"2.0","id":1385,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1385, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1196},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other eva"}]}}
Read message 
{"jsonrpc":"2.0","id":1386,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1386, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1197},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evau"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1198},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaua"}]}}
Read message 
{"jsonrpc":"2.0","id":1387,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 1387, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1199},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaual"}]}}
Read message 
{"jsonrpc":"2.0","id":1388,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1388, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1389,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":19},"end":{"line":34,"character":19}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 1389, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1390,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1390, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1391,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 1391, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1200},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaua"}]}}
Read message 
{"jsonrpc":"2.0","id":1392,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":18},"end":{"line":34,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 1392, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1393,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1393, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1394,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 1394, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1203},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other ev"}]}}
Read message 
{"jsonrpc":"2.0","id":1395,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":15},"end":{"line":34,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 1395, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1396,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 1396, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1397,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 1397, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1204},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other eva"}]}}
Read message 
{"jsonrpc":"2.0","id":1398,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1398, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1399,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":16},"end":{"line":34,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 1399, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1400,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1400, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1401,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 1401, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1205},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other eval"}]}}
Read message 
{"jsonrpc":"2.0","id":1402,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1402, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1206},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evalu"}]}}
Read message 
{"jsonrpc":"2.0","id":1403,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1403, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1207},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evalua"}]}}
Read message 
{"jsonrpc":"2.0","id":1404,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1404, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1210},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluatio"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1211},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation"}]}}
Read message 
{"jsonrpc":"2.0","id":1405,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1405, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1212},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1213},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation r"}]}}
Read message 
{"jsonrpc":"2.0","id":1406,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1406, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1214},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation ru"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1216},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rule"}]}}
Read message 
{"jsonrpc":"2.0","id":1407,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1407, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1217},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules"}]}}
Read message 
{"jsonrpc":"2.0","id":1408,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":29},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1408, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1218},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules "}]}}
Read message 
{"jsonrpc":"2.0","id":1409,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1409, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1410,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1410, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1219},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules f"}]}}
Read message 
{"jsonrpc":"2.0","id":1411,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1411, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1225},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for bui"}]}}
Read message 
{"jsonrpc":"2.0","id":1412,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":37},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1412, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1226},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for buil"}]}}
Read message 
{"jsonrpc":"2.0","id":1413,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":38},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1413, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1227},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built"}]}}
Read message 
{"jsonrpc":"2.0","id":1414,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":39},"end":{"line":34,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 1414, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1415,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 1415, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1416,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0340938568115ms
Sending response {"id": 1416, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1228},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-"}]}}
Read message 
{"jsonrpc":"2.0","id":1417,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":40},"end":{"line":34,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1417, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1418,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1418, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1419,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 1419, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1229},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-i"}]}}
Read message 
{"jsonrpc":"2.0","id":1420,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1420, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1230},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in"}]}}
Read message 
{"jsonrpc":"2.0","id":1421,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":42},"end":{"line":34,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 1421, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1422,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 1422, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1423,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1423, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1231},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in "}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1232},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in o"}]}}
Read message 
{"jsonrpc":"2.0","id":1424,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":44},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1424, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1234},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in ope"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1236},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in opera"}]}}
Read message 
{"jsonrpc":"2.0","id":1425,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":48},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1425, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1237},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operat"}]}}
Read message 
{"jsonrpc":"2.0","id":1426,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1426, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1238},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operato"}]}}
Read message 
{"jsonrpc":"2.0","id":1427,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":50},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1427, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1239},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operator"}]}}
Read message 
{"jsonrpc":"2.0","id":1428,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":51},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0138282775879ms
Sending response {"id": 1428, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1249},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and func"}]}}
Read message 
{"jsonrpc":"2.0","id":1429,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":61},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1429, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1430,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":61},"end":{"line":34,"character":61}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1430, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1431,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1431, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1432,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 1432, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1250},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and funct"}]}}
Read message 
{"jsonrpc":"2.0","id":1433,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":62},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1433, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1252},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and functio"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1255},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function a"}]}}
Read message 
{"jsonrpc":"2.0","id":1434,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":67},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1434, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1258},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function appl"}]}}
Read message 
{"jsonrpc":"2.0","id":1435,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":70},"end":{"line":34,"character":70}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1435, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1436,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 1436, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1437,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1437, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1259},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function appli"}]}}
Read message 
{"jsonrpc":"2.0","id":1438,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":71},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1438, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1260},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function applia"}]}}
Read message 
{"jsonrpc":"2.0","id":1439,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":72},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1439, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1440,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":34,"character":72},"end":{"line":34,"character":72}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1440, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1441,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1441, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1442,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1442, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1262},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function applic"}]}}
Read message 
{"jsonrpc":"2.0","id":1443,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":72},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0178813934326ms
Sending response {"id": 1443, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1267},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1268},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application."}]}}
Read message 
{"jsonrpc":"2.0","id":1444,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":34,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00476837158203ms
Sending response {"id": 1444, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1444}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1269},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1445,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1445, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1446,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1446, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1270},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -"}]}}
Read message 
{"jsonrpc":"2.0","id":1447,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":3},"end":{"line":35,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1447, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1448,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1448, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1449,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1449, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1273},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> S"}]}}
Read message 
{"jsonrpc":"2.0","id":1450,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1450, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1274},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So"}]}}
Read message 
{"jsonrpc":"2.0","id":1451,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":7},"end":{"line":35,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1451, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1452,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 1452, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1453,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1453, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1275},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So "}]}}
Read message 
{"jsonrpc":"2.0","id":1454,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1454, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1455,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1455, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1276},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So t"}]}}
Read message 
{"jsonrpc":"2.0","id":1456,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1456, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1280},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the r"}]}}
Read message 
{"jsonrpc":"2.0","id":1457,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1457, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1283},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the resu"}]}}
Read message 
{"jsonrpc":"2.0","id":1458,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":16},"end":{"line":35,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1458, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1459,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1459, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1460,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1460, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1285},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1286},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result "}]}}
Read message 
{"jsonrpc":"2.0","id":1461,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 1461, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1462,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1462, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1287},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result o"}]}}
Read message 
{"jsonrpc":"2.0","id":1463,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1463, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1290},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of t"}]}}
Read message 
{"jsonrpc":"2.0","id":1464,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1464, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1294},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the e"}]}}
Read message 
{"jsonrpc":"2.0","id":1465,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0221729278564ms
Sending response {"id": 1465, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1297},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the eint"}]}}
Read message 
{"jsonrpc":"2.0","id":1466,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":30},"end":{"line":35,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 1466, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1467,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1467, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1468,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0219345092773ms
Sending response {"id": 1468, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1300},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the e"}]}}
Read message 
{"jsonrpc":"2.0","id":1469,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":27},"end":{"line":35,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 1469, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1470,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1470, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1471,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1471, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1304},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entie"}]}}
Read message 
{"jsonrpc":"2.0","id":1472,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1472, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1305},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier"}]}}
Read message 
{"jsonrpc":"2.0","id":1473,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1473, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1306},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier "}]}}
Read message 
{"jsonrpc":"2.0","id":1474,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1474, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1475,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0290870666504ms
Sending response {"id": 1475, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1307},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier m"}]}}
Read message 
{"jsonrpc":"2.0","id":1476,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":34},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1476, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1311},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1313},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match e"}]}}
Read message 
{"jsonrpc":"2.0","id":1477,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1477, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1316},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expr"}]}}
Read message 
{"jsonrpc":"2.0","id":1478,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1478, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1319},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expresi"}]}}
Read message 
{"jsonrpc":"2.0","id":1479,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":46},"end":{"line":35,"character":46}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1479, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1480,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1480, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1481,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1481, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1320},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expresis"}]}}
Read message 
{"jsonrpc":"2.0","id":1482,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":47},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1482, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1482}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1321},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expresi"}]}}
Read message 
{"jsonrpc":"2.0","id":1483,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":46},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1483, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1483}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1322},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expres"}]}}
Read message 
{"jsonrpc":"2.0","id":1484,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1484, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1335},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true."}]}}
Read message 
{"jsonrpc":"2.0","id":1485,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1485, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1486,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":58},"end":{"line":35,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1486, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1487,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1487, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1488,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1488, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1489,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":35,"character":57}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0350475311279ms
Sending response {"id": 1489, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1490,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":56},"end":{"line":35,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 1490, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1491,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1491, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1492,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 1492, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1493,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":19,"character":35},"end":{"line":35,"character":58}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":9}},"message":"Unbound constructor Dynamic","severity":1,"source":"merlin"},{"range":{"start":{"line":21,"character":19},"end":{"line":21,"character":20}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.053882598877ms
Sending response {"id": 1493, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1494,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1494, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1495,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":20,"character":0},"end":{"line":35,"character":58}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":9}},"message":"Unbound constructor Dynamic","severity":1,"source":"merlin"},{"range":{"start":{"line":21,"character":19},"end":{"line":21,"character":20}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Sending response {"id": 1495, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1496,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0112056732178ms
Sending response {"id": 1496, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1497,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":20},"end":{"line":35,"character":58}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":19},"end":{"line":21,"character":20}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 1497, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1498,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 1498, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1499,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":18},"end":{"line":35,"character":58}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":19},"end":{"line":21,"character":20}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 1499, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1500,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0181198120117ms
Sending response {"id": 1500, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1501,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":2},"end":{"line":35,"character":58}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":9}},"message":"Unbound constructor Dynamic","severity":1,"source":"merlin"},{"range":{"start":{"line":21,"character":19},"end":{"line":21,"character":20}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 1501, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1502,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1502, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1336},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)"}]}}
Read message 
{"jsonrpc":"2.0","id":1503,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":5},"end":{"line":35,"character":58}},"context":{"diagnostics":[{"range":{"start":{"line":21,"character":2},"end":{"line":21,"character":9}},"message":"Unbound constructor Dynamic","severity":1,"source":"merlin"},{"range":{"start":{"line":21,"character":19},"end":{"line":21,"character":20}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 1503, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1504,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 1504, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1505,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0770092010498ms
Sending response {"id": 1505, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1506,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":32,"character":24}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 1506, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1507,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":21,"character":5},"end":{"line":35,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 1507, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1508,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":35,"character":61},"end":{"line":35,"character":61}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1508, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1509,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1509, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1339},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  "}]}}
Read message 
{"jsonrpc":"2.0","id":1510,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 1510, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1511,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 1511, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1512,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 1512, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1340},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1513,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1513, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1514,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 1514, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1341},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  A\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1515,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1515, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1343},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  ADd\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1516,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0309944152832ms
Sending response {"id": 1516, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1517,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":5},"end":{"line":38,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.028133392334ms
Sending response {"id": 1517, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1518,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1518, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1519,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 1519, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1344},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  ADdi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1520,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0171661376953ms
Sending response {"id": 1520, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1349},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  ADditioan\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1521,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":11},"end":{"line":38,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0371932983398ms
Sending response {"id": 1521, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1522,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 1522, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1523,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1523, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1358},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Ad\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1524,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.108003616333ms
Sending response {"id": 1524, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1359},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Add\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1525,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0159740447998ms
Sending response {"id": 1525, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1360},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Addi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1526,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":6},"end":{"line":38,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1526, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1527,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1527, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1528,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1528, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1361},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Addit\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1529,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1529, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1366},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1368},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional s\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1530,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1530, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1369},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional st\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1531,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":15},"end":{"line":38,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1531, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1532,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1532, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1533,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1533, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1534,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":15},"end":{"line":38,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1534, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1371},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional stat\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1535,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":17},"end":{"line":38,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1535, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1536,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0238418579102ms
Sending response {"id": 1536, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1537,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1537, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1372},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional stati\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1538,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1538, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1539,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":18},"end":{"line":38,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1539, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1373},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1540,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1540, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1374},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1541,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1541, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1542,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1542, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1375},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1543,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 1543, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1379},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static check\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1380},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checki\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1544,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":38,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1544, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1382},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1545,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":28},"end":{"line":38,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1545, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1546,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1546, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1547,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1547, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1383},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1385},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1548,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0278949737549ms
Sending response {"id": 1548, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1549,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 1549, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1386},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  I\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1550,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1550, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1388},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1389},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1551,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1551, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1552,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1552, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1391},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In A\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1553,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1553, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1554,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":6},"end":{"line":40,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1554, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1555,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1555, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1556,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0228881835938ms
Sending response {"id": 1556, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1393},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1557,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1557, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1395},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In add\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1396},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1558,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1558, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1397},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addit\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1559,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1559, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1398},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In additi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1560,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1560, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1399},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In additio\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1561,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1561, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1400},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1562,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1562, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1401},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1402},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1563,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.02121925354ms
Sending response {"id": 1563, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1403},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1405},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1564,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1564, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1410},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1565,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1565, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1566,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":23},"end":{"line":40,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1566, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1567,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1567, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1568,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1568, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1569,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":23},"end":{"line":40,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 1569, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1411},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that ty\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1570,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1570, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1571,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":24},"end":{"line":40,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1571, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1413},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1414},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1572,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":27},"end":{"line":40,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1572, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1415},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1573,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1573, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1417},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-che\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1574,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1574, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1419},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-check\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1420},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checki\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1575,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1575, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1425},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking ru\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1576,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":38},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0700950622559ms
Sending response {"id": 1576, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1429},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1430},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1577,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1577, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1432},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, the\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1434},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1578,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":47},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1578, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1439},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1579,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 1579, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1440},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1580,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1580, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1581,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":53},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1581, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1441},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are tw\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1582,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":54},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1582, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1463},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the com\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1583,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":76},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1583, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1465},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1584,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1584, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1585,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":78},"end":{"line":40,"character":78}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1585, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1586,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1586, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1587,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1587, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1466},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comp\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1467},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compp\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1588,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1588, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1468},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comppi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1589,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":79},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1589, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1469},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comppil\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1590,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":80},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1590, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1470},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comppile\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1591,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":81},"end":{"line":40,"character":81}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0288486480713ms
Sending response {"id": 1591, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1592,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1592, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1593,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1593, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1471},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comppiler\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1594,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":82},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1594, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1472},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comppiler \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1595,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1595, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1596,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1596, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1473},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comppiler d\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1597,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":84},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1597, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1597}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1480},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the comp\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1598,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":77},"end":{"line":40,"character":77}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.03981590271ms
Sending response {"id": 1598, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1599,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1599, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1600,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0250339508057ms
Sending response {"id": 1600, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1481},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1601,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1601, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1482},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compil\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1602,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":79},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1602, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1483},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compile\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1603,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":80},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1603, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1484},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1604,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":81},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1604, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1494},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1495},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for e\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1605,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":92},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1605, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1496},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for ea\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1497},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for eac\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1606,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":94},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0300407409668ms
Sending response {"id": 1606, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1607,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":40,"character":94},"end":{"line":40,"character":94}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 1607, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1608,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1608, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1609,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 1609, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1498},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1610,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":95},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1610, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1508},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc exp\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1611,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":105},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1611, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1510},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expre\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1612,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":40,"character":107},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00977516174316ms
Sending response {"id": 1612, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1612}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1516},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1613,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0269412994385ms
Sending response {"id": 1613, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1614,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1614, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1517},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1615,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 1615, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1616,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1616, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1518},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  F\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1617,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1617, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1522},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1618,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":7},"end":{"line":42,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0331401824951ms
Sending response {"id": 1618, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1619,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 1619, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1620,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1620, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1524},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1621,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.018835067749ms
Sending response {"id": 1621, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1622,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1622, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1525},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, e\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1623,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1623, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1527},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exh\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1624,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":12},"end":{"line":42,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1624, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1625,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1625, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1626,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1626, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1528},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exha\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1627,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1627, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1530},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaus\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1531},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaust\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1628,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1628, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1532},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhausti\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1629,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1629, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1533},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiv\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1630,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1630, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1534},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustive\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1631,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1631, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1535},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiven\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1632,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1632, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1536},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustivene\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1633,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 1633, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1539},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness.\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1634,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":24},"end":{"line":42,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0300407409668ms
Sending response {"id": 1634, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1635,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 1635, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1636,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1636, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1637,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":24},"end":{"line":42,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0371932983398ms
Sending response {"id": 1637, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1540},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1638,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1638, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1639,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1639, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1541},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. T\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1640,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Sending response {"id": 1640, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1549},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compi\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1550},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compil\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1641,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1641, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1551},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compile\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1554},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1642,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1642, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1556},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler che\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1643,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1643, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1563},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1644,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 1644, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1645,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1645, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1564},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to m\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1646,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":49},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1646, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1580},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that th\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1647,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":65},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0112056732178ms
Sending response {"id": 1647, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1581},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that the\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1585},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1648,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":70},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1648, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1586},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there ar\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1588},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1649,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 1649, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1650,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1650, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1589},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are e\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1651,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":74},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1651, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1593},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enogu\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1652,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":78},"end":{"line":42,"character":78}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1652, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1653,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1653, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1654,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0228881835938ms
Sending response {"id": 1654, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1596},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enou\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1655,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":77},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0159740447998ms
Sending response {"id": 1655, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1598},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1656,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":79},"end":{"line":42,"character":79}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 1656, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1657,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1657, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1658,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 1658, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1599},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1659,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1659, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1660,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 1660, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1600},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough p\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1661,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":81},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1661, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1603},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patt\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1604},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patte\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1662,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":85},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1662, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1605},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patter\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1663,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":86},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1663, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1606},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough pattern\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1664,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":87},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1664, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1607},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1665,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":88},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1665, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1610},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1612},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to g\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1666,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":93},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0200271606445ms
Sending response {"id": 1666, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1617},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guaran\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1667,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":98},"end":{"line":42,"character":98}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1667, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1668,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 1668, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1669,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0319480895996ms
Sending response {"id": 1669, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1618},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarant\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1670,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":99},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.046968460083ms
Sending response {"id": 1670, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1671,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":99},"end":{"line":42,"character":99}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0247955322266ms
Sending response {"id": 1671, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1672,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.123977661133ms
Sending response {"id": 1672, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1673,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1673, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1619},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarante\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1674,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":100},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1674, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1620},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1675,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":101},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0321865081787ms
Sending response {"id": 1675, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1676,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":42,"character":101},"end":{"line":42,"character":101}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 1676, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1677,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1677, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1678,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 1678, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1622},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1679,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":42,"character":103},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.018835067749ms
Sending response {"id": 1679, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1625},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1627},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1680,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 1680, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1629},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1630},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at l\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1681,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0288486480713ms
Sending response {"id": 1681, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1631},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at le\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1632},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at lea\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1682,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0138282775879ms
Sending response {"id": 1682, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1683,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":8},"end":{"line":43,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 1683, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1684,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1684, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1685,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 1685, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1633},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at le\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1686,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":7},"end":{"line":43,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 1686, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1687,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0288486480713ms
Sending response {"id": 1687, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1688,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1688, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1634},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at lea\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1689,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1689, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1635},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at leas\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1690,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1690, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1636},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1691,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1691, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1649},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1692,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 1692, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1693,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1693, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1650},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them m\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1694,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 1694, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1652},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them mat\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1656},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1695,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1695, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1658},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1696,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1696, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1662},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the e\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1697,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":36},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1697, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1665},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expr\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1698,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1698, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1666},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expre\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1699,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 1699, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1670},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expressio\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1671},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1700,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 1700, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1674},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e,\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1701,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":48},"end":{"line":43,"character":48}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1701, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1702,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1702, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1703,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0262260437012ms
Sending response {"id": 1703, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1676},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1704,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":50},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1704, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1679},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no m\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1705,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":53},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 1705, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1682},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matt\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1683},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matte\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1684},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1706,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1706, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1686},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1707,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1707, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1688},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter the\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1708,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":62},"end":{"line":43,"character":62}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1708, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1709,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1709, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1710,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1710, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1692},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter w\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1711,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1711, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1706},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1707},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value o\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1712,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":75},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1712, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1710},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1713,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0178813934326ms
Sending response {"id": 1713, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1723},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expressio\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1714,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":91},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1714, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1726},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression i\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1715,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":94},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1715, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1729},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1716,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":97},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1716, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1730},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1717,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":98},"end":{"line":43,"character":98}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1717, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1718,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1718, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1719,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 1719, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1731},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1732},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at r\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1720,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":43,"character":100},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 1720, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1741},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.,\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1721,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":109},"end":{"line":43,"character":109}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1721, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1722,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1722, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1723,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1723, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1724,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":109},"end":{"line":43,"character":109}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0917911529541ms
Sending response {"id": 1724, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1742},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1725,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":43,"character":108},"end":{"line":43,"character":108}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0560283660889ms
Sending response {"id": 1725, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1726,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 1726, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1727,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Sending response {"id": 1727, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1743},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1728,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 1728, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1729,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0209808349609ms
Sending response {"id": 1729, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1744},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  T\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1730,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1730, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1746},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  Thi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1731,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0138282775879ms
Sending response {"id": 1731, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1753},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensur\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1754},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensure\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1732,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1732, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1755},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1733,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1733, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1757},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1734,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1734, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1759},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures the\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1735,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":18},"end":{"line":44,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 1735, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1736,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1736, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1737,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1737, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1761},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures tha\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1762},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1738,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1738, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1764},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that p\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1739,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1739, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1767},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that prog\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1740,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1740, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1741,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":24},"end":{"line":44,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1741, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1742,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1742, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1743,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1743, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1768},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that progr\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1744,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1744, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1769},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that progra\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1745,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1745, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1774},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1746,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00977516174316ms
Sending response {"id": 1746, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1747,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1747, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1775},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer d\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1748,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00977516174316ms
Sending response {"id": 1748, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1779},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1749,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":36},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1749, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1783},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not f\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1750,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":40},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1750, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1751,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":40},"end":{"line":44,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1751, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1752,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1752, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1753,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1753, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1786},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forg\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1787},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forge\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1754,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":44},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1754, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1789},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1755,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 1755, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1756,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Sending response {"id": 1756, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1790},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1757,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":47},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1757, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1802},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches.\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1758,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":59},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0298023223877ms
Sending response {"id": 1758, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1759,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":59},"end":{"line":44,"character":59}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1759, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1760,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1760, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1761,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1761, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1804},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. F\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1762,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":61},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 1762, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1811},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For exam\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1812},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For examp\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1763,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":69},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1763, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1814},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1764,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":71},"end":{"line":44,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0338554382324ms
Sending response {"id": 1764, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1765,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1765, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1766,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1766, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1767,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":71},"end":{"line":44,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 1767, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1815},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1768,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 1768, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1769,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0197887420654ms
Sending response {"id": 1769, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1770,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":71},"end":{"line":44,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1770, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1818},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1771,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":74},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1771, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1822},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the f\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1772,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1772, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1825},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the func\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1773,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":81},"end":{"line":44,"character":81}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1773, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1774,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 1774, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1775,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1775, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1831},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1776,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":87},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00476837158203ms
Sending response {"id": 1776, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1832},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function be\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1777,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":44,"character":88},"end":{"line":44,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1777, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1778,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1778, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1779,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1779, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1833},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function bel\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1780,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":89},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1780, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1834},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function belo\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1781,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":90},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 1781, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1836},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1837},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below w\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1782,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":93},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1782, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1840},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1842},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1783,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":44,"character":98},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1783, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1783}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1847},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1784,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 1784, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1785,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 1785, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1848},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1786,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 1786, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1852},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1787,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1787, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1854},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the com\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1856},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1788,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1788, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1859},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1860},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1789,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0300407409668ms
Sending response {"id": 1789, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1790,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1790, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1861},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1791,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1791, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1864},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to e\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1792,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1792, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1866},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1793,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1793, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1872},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a wa\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1794,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1794, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1795,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":45,"character":27},"end":{"line":45,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1795, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1796,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 1796, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1797,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1797, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1873},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a war\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1798,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":45,"character":28},"end":{"line":45,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 1798, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1799,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 1799, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1800,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 1800, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1874},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warn\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1801,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":29},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1801, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1875},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warni\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1802,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":45,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1802, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1878},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1803,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":45,"character":33},"end":{"line":45,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1803, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1804,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 1804, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1805,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1805, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1879},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1806,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 1806, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1807,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1807, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1880},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  l\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1808,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1808, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1881},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  le\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1883},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1884},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let h\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1809,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1809, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1885},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let he\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1810,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1810, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1888},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1811,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1811, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1812,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1812, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1892},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1813,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1813, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1814,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1814, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1895},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = m\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1815,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1815, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1897},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = mat\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1899},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1901},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match l\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1816,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1816, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1904},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1905},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst w\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1817,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0181198120117ms
Sending response {"id": 1817, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1906},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst wi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1818,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":29},"end":{"line":46,"character":29}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1818, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1819,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 1819, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1820,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0209808349609ms
Sending response {"id": 1820, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1908},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1821,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":31},"end":{"line":46,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0300407409668ms
Sending response {"id": 1821, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1822,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1822, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1823,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1823, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1909},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1824,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1824, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1825,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1825, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1914},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h __ \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1826,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1826, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1827,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1827, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1920},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1828,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 1828, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1829,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00786781311035ms
Sending response {"id": 1829, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1923},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ =\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1830,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":40},"end":{"line":46,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1830, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1831,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1831, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1832,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1832, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1925},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1833,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":40},"end":{"line":46,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0209808349609ms
Sending response {"id": 1833, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1927},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1834,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1834, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1835,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 1835, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1928},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1836,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":46,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0300407409668ms
Sending response {"id": 1836, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1837,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":43},"end":{"line":46,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 1837, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1838,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 1838, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1839,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1839, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1840,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":43},"end":{"line":46,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1840, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1929},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1841,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 1841, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1842,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1842, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1843,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":46,"character":43},"end":{"line":46,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 1843, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1931},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1844,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 1844, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1845,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 1845, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1932},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  S\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1846,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Sending response {"id": 1846, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1933},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Se\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1936},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Secin\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1847,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00476837158203ms
Sending response {"id": 1847, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1937},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Secind\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1848,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1848, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1849,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":8},"end":{"line":48,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 1849, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1850,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 1850, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1851,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1851, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1938},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Secind,\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1852,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":9},"end":{"line":48,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 1852, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1853,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 1853, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1854,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1854, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1942},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Sec\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1855,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":5},"end":{"line":48,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 1855, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1856,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 1856, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1857,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 1857, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1943},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Seco\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1858,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1858, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1946},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second,\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1947},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1859,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1859, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1860,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1860, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1948},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, u\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1861,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1861, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1952},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unuse\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1862,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1862, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1954},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1955},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1863,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1863, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1957},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused bra\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1864,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0669956207275ms
Sending response {"id": 1864, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1962},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1964},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1865,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 1865, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1866,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1866, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1965},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1867,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Sending response {"id": 1867, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1968},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1969},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1868,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 1868, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1972},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the comp\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1869,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":35},"end":{"line":48,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 1869, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1870,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 1870, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1871,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 1871, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1872,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":35},"end":{"line":48,"character":35}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 1872, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1973},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1873,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":36},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1873, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1975},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compile\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1976},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1874,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":39},"end":{"line":48,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 1874, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1977},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1875,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 1875, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1876,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 1876, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1978},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1877,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1877, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1980},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler che\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1878,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1878, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1981},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler chec\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1879,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":44},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1879, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1982},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler check\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1880,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 1880, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1986},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1988},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to s\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1881,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":51},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1881, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1992},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see w\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1882,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":55},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1882, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1995},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see wher\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1883,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1883, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1884,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":58},"end":{"line":48,"character":58}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1884, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1885,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 1885, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1886,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1886, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1997},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whet\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1887,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0147819519043ms
Sending response {"id": 1887, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":1999},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whethe\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2000},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1888,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":61},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1888, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2001},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1889,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1889, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1890,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 1890, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2002},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1891,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":63},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1891, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2004},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1892,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":65},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1892, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2006},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any o\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1893,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":67},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 1893, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2012},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2013},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1894,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":74},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1894, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2022},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches c\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1895,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":83},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 1895, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2024},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches cou\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2025},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches coul\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1896,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":86},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00286102294922ms
Sending response {"id": 1896, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2026},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1897,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":87},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1897, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1898,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":87},"end":{"line":48,"character":87}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 1898, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1899,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1899, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1900,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1900, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2027},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1901,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 1901, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1902,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 1902, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2028},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1903,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":89},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1903, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2031},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could neve\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2033},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1904,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1904, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1905,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1905, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2034},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1906,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":95},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1906, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2036},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2037},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be m\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1907,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":98},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1907, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2043},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matches\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1908,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":48,"character":104},"end":{"line":48,"character":104}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1908, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1909,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00190734863281ms
Sending response {"id": 1909, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1910,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 1910, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2045},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1911,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":48,"character":104},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1911, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1911}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2046},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1912,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1912, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1913,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 1913, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2047},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1914,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1914, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2059},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against becau\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1915,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 1915, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1916,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":15},"end":{"line":49,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 1916, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1917,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 1917, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1918,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00309944152832ms
Sending response {"id": 1918, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2062},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2063},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because o\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1919,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 1919, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2068},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2070},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1920,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00286102294922ms
Sending response {"id": 1920, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2073},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2074},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the p\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1921,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 1921, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2077},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the pore\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2080},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the p\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1922,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":30},"end":{"line":49,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 1922, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1923,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 1923, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1924,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1924, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2084},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the prevu\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1925,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":34},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1925, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1926,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":34},"end":{"line":49,"character":34}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 1926, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1927,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1927, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1928,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1928, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2086},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previ\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1929,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":34},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1929, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2087},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previo\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1930,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1930, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2090},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1931,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 1931, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1932,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 1932, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2091},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1933,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 1933, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2109},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guarant\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1934,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":57},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1934, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2112},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1935,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1935, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2113},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2114},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1936,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":62},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 1936, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2117},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to s\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1937,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":65},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1937, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2120},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succ\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1938,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":68},"end":{"line":49,"character":68}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 1938, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1939,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 1939, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1940,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 1940, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2121},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succe\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1941,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":69},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1941, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2122},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succee\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1942,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":70},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 1942, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2123},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1943,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":71},"end":{"line":49,"character":71}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 1943, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1944,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 1944, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1945,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1945, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2124},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed.\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1946,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":72},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 1946, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2126},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. F\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1947,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":74},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1947, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2130},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For e\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1948,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 1948, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2134},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For eaxmp\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1949,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":82},"end":{"line":49,"character":82}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0371932983398ms
Sending response {"id": 1949, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1950,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 1950, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1951,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0240802764893ms
Sending response {"id": 1951, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2144},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2145},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example,\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1952,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":85},"end":{"line":49,"character":85}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 1952, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1953,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 1953, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1954,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 1954, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2146},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1955,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 1955, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1956,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 1956, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2147},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, f\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1957,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":87},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1957, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2149},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, fht\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2150},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, fhte\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1958,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":90},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1958, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2151},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, fhte \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2152},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, fhte f\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1959,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":92},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 1959, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1960,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":92},"end":{"line":49,"character":92}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 1960, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1961,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 1961, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1962,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 1962, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2158},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1963,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 1963, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1964,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1964, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2159},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1965,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":87},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0159740447998ms
Sending response {"id": 1965, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2166},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the func\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1966,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":49,"character":94},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 1966, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2169},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the functio\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2176},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1967,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":104},"end":{"line":49,"character":104}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 1967, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1968,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 1968, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1969,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1969, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2177},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2179},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below is\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1970,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":49,"character":107},"end":{"line":49,"character":107}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 1970, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1971,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00715255737305ms
Sending response {"id": 1971, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1972,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1972, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2181},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1973,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0331401824951ms
Sending response {"id": 1973, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1974,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1974, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2184},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  wi\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2186},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2200},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the com\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2202},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compi\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2206},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1975,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 1975, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1976,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 1976, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2208},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1977,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":50,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 1977, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2214},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2218},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a wa\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1978,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":50,"character":38},"end":{"line":50,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0338554382324ms
Sending response {"id": 1978, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1979,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 1979, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1980,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 1980, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2223},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1981,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":50,"character":43},"end":{"line":50,"character":43}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 1981, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1982,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0779628753662ms
Sending response {"id": 1982, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1983,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1983, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2224},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2226},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1984,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 1984, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1985,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 1985, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2229},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1986,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":52,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1986, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2231},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let r\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2233},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1987,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":52,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 1987, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2234},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1988,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 1988, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1989,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 1989, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2236},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec su\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1990,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":52,"character":12},"end":{"line":52,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 1990, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1991,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 1991, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1992,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 1992, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2237},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2245},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    \n"}]}}
Read message 
{"jsonrpc":"2.0","id":1993,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 1993, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1994,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 1994, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2250},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1995,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":53,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 1995, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2251},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2259},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1996,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":53,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 1996, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2260},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n"}]}}
Read message 
{"jsonrpc":"2.0","id":1997,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":53,"character":18},"end":{"line":53,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 1997, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1998,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 1998, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":1999,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0238418579102ms
Sending response {"id": 1999, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2261},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2000,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 2000, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2001,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2001, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2262},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    |\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2002,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":54,"character":5},"end":{"line":54,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2002, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2003,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 2003, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2004,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2004, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2263},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2005,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 2005, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2006,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2006, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2265},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2268},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2271},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2007,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":54,"character":14},"end":{"line":54,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2007, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2008,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0288486480713ms
Sending response {"id": 2008, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2009,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2009, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2273},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2274},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2010,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":54,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2010, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2278},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + s\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2011,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":54,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 2011, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2011}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2283},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2012,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0300407409668ms
Sending response {"id": 2012, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2013,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2013, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2284},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    |\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2285},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2014,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2014, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2015,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 2015, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2286},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | []\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2016,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":55,"character":7},"end":{"line":55,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 2016, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2017,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 2017, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2018,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2018, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2019,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":55,"character":7},"end":{"line":55,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0388622283936ms
Sending response {"id": 2019, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2288},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h]\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2289},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ]\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2020,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 2020, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2290},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2291},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2021,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":55,"character":13},"end":{"line":55,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.018835067749ms
Sending response {"id": 2021, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2022,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 2022, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2023,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 2023, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2293},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2024,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2024, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2025,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2025, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2294},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2026,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":55,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2026, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2027,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":55,"character":16},"end":{"line":55,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 2027, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2028,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2028, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2029,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2029, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2295},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2296},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2030,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0381469726562ms
Sending response {"id": 2030, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2031,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2031, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2298},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2032,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2032, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2033,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2033, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2299},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | []\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2034,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":56,"character":7},"end":{"line":56,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0278949737549ms
Sending response {"id": 2034, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2035,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 2035, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2036,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2036, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2301},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2037,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":56,"character":10},"end":{"line":56,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0429153442383ms
Sending response {"id": 2037, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2038,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 2038, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2039,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 2039, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2303},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2304},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2040,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":56,"character":13},"end":{"line":56,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 2040, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2041,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2041, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2042,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 2042, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2043,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":56,"character":13},"end":{"line":56,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0371932983398ms
Sending response {"id": 2043, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2306},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n    \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2307},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2044,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0348091125488ms
Sending response {"id": 2044, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2045,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 2045, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2308},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  H\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2046,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 2046, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2309},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  He\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2047,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 2047, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2319},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2320},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2048,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":15},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2048, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2322},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second bra\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2049,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2049, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2323},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second bran\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2050,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2050, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2324},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branc\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2051,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 2051, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2325},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2052,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2052, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2327},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch i\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2053,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2053, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2329},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2330},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is u\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2054,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":25},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 2054, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2331},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is un\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2055,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":58,"character":26},"end":{"line":58,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2055, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2056,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 2056, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2057,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2057, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2333},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unus\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2334},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unuse\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2058,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":29},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2058, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2336},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2059,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2059, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2060,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2060, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2337},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2061,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2061, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2350},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the fi\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2062,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2062, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2063,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":58,"character":45},"end":{"line":58,"character":45}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 2063, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2064,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2064, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2065,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2065, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2351},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the fir\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2066,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":58,"character":46},"end":{"line":58,"character":46}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0319480895996ms
Sending response {"id": 2066, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2067,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 2067, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2068,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 2068, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2355},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2069,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":50},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Sending response {"id": 2069, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2360},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2362},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch w\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2070,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":57},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2070, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2363},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch wi\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2365},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2071,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":60},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2071, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2367},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will m\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2072,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":62},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2072, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2368},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will ma\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2369},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will mat\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2371},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2373},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match a\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2073,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":68},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2073, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2374},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match an\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2375},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match any\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2376},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anyt\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2074,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":71},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2074, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2381},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2075,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2075, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2076,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 2076, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2382},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything t\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2077,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":77},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2077, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2385},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2078,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2078, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2079,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2079, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2386},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the s\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2080,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":81},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2080, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2081,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":58,"character":81},"end":{"line":58,"character":81}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 2081, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2082,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2082, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2083,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2083, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2388},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the sec\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2084,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":83},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2084, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2389},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the seco\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2085,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":84},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2085, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2390},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the secon\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2086,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":85},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2086, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2391},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2087,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":86},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2087, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2392},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second \n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2393},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second b\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2088,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":88},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2088, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2402},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch mat\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2089,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":97},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 2089, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2407},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches.\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2090,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":58,"character":102},"end":{"line":58,"character":102}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 2090, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2091,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2091, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2092,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2092, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2408},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches.\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2093,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2093, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2094,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 2094, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2409},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches.\n\n  \n"}]}}
Read message 
{"jsonrpc":"2.0","id":2095,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2095, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2096,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2096, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2097,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2097, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2098,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2098, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2099,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":102}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 2099, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":39,"character":0},"end":{"line":58,"character":102}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2100, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2101,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 2101, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2102,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":0},"end":{"line":58,"character":102}},"context":{"diagnostics":[{"range":{"start":{"line":38,"character":2},"end":{"line":38,"character":12}},"message":"Unbound constructor Additional","severity":1,"source":"merlin"},{"range":{"start":{"line":38,"character":20},"end":{"line":38,"character":28}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0228881835938ms
Sending response {"id": 2102, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2103,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.018835067749ms
Sending response {"id": 2103, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2410},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2104,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 2104, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2105,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0147819519043ms
Sending response {"id": 2105, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2106,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":38,"character":0},"end":{"line":58,"character":102}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2106, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2107,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0319480895996ms
Sending response {"id": 2107, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2412},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2108,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 2108, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2109,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0219345092773ms
Sending response {"id": 2109, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2413},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  O\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2110,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2110, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2416},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2417},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One o\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2111,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0159740447998ms
Sending response {"id": 2111, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2418},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2112,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":8},"end":{"line":61,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 2112, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2419},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2113,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2113, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2114,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2114, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2420},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of t\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2115,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2115, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2427},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2116,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2116, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2428},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2117,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 2117, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2118,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 2118, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2429},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good c\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2119,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2119, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2430},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good ca\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2120,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":20},"end":{"line":61,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 2120, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2121,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 2121, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2122,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2122, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2432},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cx\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2123,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":20},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2123, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2434},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxam\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2435},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxamp\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2124,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2124, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2436},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxampl\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2125,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Sending response {"id": 2125, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2437},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxample\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2126,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":25},"end":{"line":61,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 2126, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2127,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.02121925354ms
Sending response {"id": 2127, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2128,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2128, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2129,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":25},"end":{"line":61,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0710487365723ms
Sending response {"id": 2129, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2438},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxample \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2130,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0238418579102ms
Sending response {"id": 2130, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2131,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2131, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2439},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxample\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2132,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":25},"end":{"line":61,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 2132, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2133,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.028133392334ms
Sending response {"id": 2133, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2134,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0240802764893ms
Sending response {"id": 2134, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2440},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good cxampl\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2446},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2447},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good a\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2135,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":19},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 2135, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2451},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and c\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2136,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2136, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2453},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and com\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2137,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":25},"end":{"line":61,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 2137, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2138,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2138, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2139,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2139, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2454},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and como\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2140,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.014066696167ms
Sending response {"id": 2140, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2141,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":26},"end":{"line":61,"character":26}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 2141, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2142,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2142, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2143,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2143, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2455},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and com\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2456},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and comm\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2144,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":26},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2144, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2457},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and commo\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2145,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 2145, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2458},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2146,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2146, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2460},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common e\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2147,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2147, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2462},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common exa\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2148,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2148, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2463},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common exam\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2149,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":33},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 2149, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2466},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2467},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2150,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2150, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2151,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2151, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2468},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example o\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2152,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":38},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2152, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2470},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2471},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of b\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2153,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2153, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2472},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bu\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2154,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00286102294922ms
Sending response {"id": 2154, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2473},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bug\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2155,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 2155, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2474},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2156,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":44},"end":{"line":61,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Sending response {"id": 2156, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2157,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 2157, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2158,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2158, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2476},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs t\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2159,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":46},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2159, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2484},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that caus\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2160,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":54},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2160, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2161,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":54},"end":{"line":61,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 2161, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2162,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 2162, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2163,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 2163, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2486},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2487},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2164,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 2164, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2165,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2165, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2488},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes u\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2166,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2166, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2489},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes un\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2167,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":59},"end":{"line":61,"character":59}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 2167, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2168,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2168, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2169,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2169, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2492},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2170,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":58},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2170, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2496},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unu\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2171,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":62},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2171, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2500},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2501},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused m\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2172,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":67},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 2172, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2505},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2506},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2173,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 2173, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2174,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2174, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2507},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match s\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2175,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":73},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 2175, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2176,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":73},"end":{"line":61,"character":73}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2176, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2177,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2177, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2178,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2178, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2509},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match c\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2179,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":73},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 2179, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2514},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case w\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2180,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":61,"character":78},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2180, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2515},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case wa\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2181,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":79},"end":{"line":61,"character":79}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2181, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2182,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2182, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2183,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2183, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2521},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2184,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":61,"character":85},"end":{"line":61,"character":85}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2184, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2185,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 2185, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2186,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2186, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2522},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2187,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2187, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2188,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2188, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2523},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2189,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 2189, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2190,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0147819519043ms
Sending response {"id": 2190, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2524},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2191,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2191, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2527},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2528},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2192,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 2192, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2530},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let len\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2193,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2193, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2531},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let leng\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2194,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 2194, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2533},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2195,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":62,"character":12},"end":{"line":62,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 2195, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2196,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2196, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2197,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 2197, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2534},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2198,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2198, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2199,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":62,"character":13},"end":{"line":62,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2199, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2200,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2200, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2201,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2201, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2202,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":62,"character":13},"end":{"line":62,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2202, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2535},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_i\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2203,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 2203, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2541},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2542},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2204,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":62,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 2204, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2545},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2546},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2205,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 2205, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2206,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 2206, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2547},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    m\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2207,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2207, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2552},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2208,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00691413879395ms
Sending response {"id": 2208, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2209,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2209, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2553},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match L\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2210,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2210, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2557},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2558},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2211,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":16},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0169277191162ms
Sending response {"id": 2211, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2561},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.leng\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2563},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.lengtr\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2212,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2212, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2564},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.lengtrh\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2213,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2213, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2214,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":63,"character":22},"end":{"line":63,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2214, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2215,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2215, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2216,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 2216, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2566},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.lengt\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2217,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":63,"character":20},"end":{"line":63,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2217, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2218,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2218, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2219,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 2219, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2567},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2220,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":21},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0319480895996ms
Sending response {"id": 2220, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2221,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":63,"character":21},"end":{"line":63,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0219345092773ms
Sending response {"id": 2221, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2222,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 2222, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2223,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 2223, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2568},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2224,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 2224, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2225,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2225, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2569},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length k\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2226,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2226, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2570},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length ks\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2227,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":24},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2227, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2228,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":63,"character":24},"end":{"line":63,"character":24}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 2228, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2229,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2229, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2230,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00476837158203ms
Sending response {"id": 2230, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2573},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2231,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":23},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2231, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2576},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2232,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 2232, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2233,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 2233, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2577},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst w\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2234,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0128746032715ms
Sending response {"id": 2234, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2578},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst wi\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2235,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":63,"character":28},"end":{"line":63,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 2235, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2236,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2236, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2237,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 2237, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2580},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2238,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":63,"character":30},"end":{"line":63,"character":30}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2238, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2239,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 2239, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2240,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2240, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2581},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2241,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 2241, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2242,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2242, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2582},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2243,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 2243, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2244,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 2244, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2584},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2245,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 2245, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2246,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2246, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2586},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2247,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2247, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2248,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2248, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2587},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2590},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> t\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2249,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":64,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2249, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2592},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> tru\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2594},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2250,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":64,"character":15},"end":{"line":64,"character":15}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 2250, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2251,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0319480895996ms
Sending response {"id": 2251, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2252,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2252, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2595},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2253,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2253, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2254,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2254, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2597},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2599},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2255,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 2255, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2256,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2256, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2600},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2257,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":65,"character":9},"end":{"line":65,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 2257, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2258,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2258, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2259,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2259, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2602},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2603},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> f\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2260,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":65,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2260, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2605},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> fal\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2261,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":65,"character":14},"end":{"line":65,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 2261, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2262,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2262, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2263,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2263, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2607},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2264,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":65,"character":16},"end":{"line":65,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 2264, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2265,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2265, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2266,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2266, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2267,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":65,"character":16},"end":{"line":65,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 2267, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2268,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":63,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 2268, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2269,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":64,"character":15}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Sending response {"id": 2269, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2270,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":65,"character":16}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 2270, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2271,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":65,"character":16},"end":{"line":65,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2271, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2272,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2272, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2609},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\n    \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2273,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0379085540771ms
Sending response {"id": 2273, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2274,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2274, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2610},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2275,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0371932983398ms
Sending response {"id": 2275, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2276,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2276, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2611},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2277,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 2277, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2278,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 2278, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2612},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nH\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2279,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2279, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2613},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHe\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2614},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHer\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2280,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2280, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2615},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2281,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2281, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2282,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":4},"end":{"line":67,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 2282, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2283,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 2283, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2284,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 2284, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2616},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2285,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2285, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2286,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 2286, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2617},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere T\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2287,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0240802764893ms
Sending response {"id": 2287, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2619},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere Thi\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2288,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00381469726562ms
Sending response {"id": 2288, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2620},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2289,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0269412994385ms
Sending response {"id": 2289, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2290,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":9},"end":{"line":67,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 2290, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2291,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2291, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2292,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2292, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2621},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2622},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This f\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2293,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2293, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2625},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This func\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2628},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functiu\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2294,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2294, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2629},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functiuo\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2295,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2295, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2296,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":18},"end":{"line":67,"character":18}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 2296, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2297,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2297, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2298,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2298, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2631},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functi\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2299,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":16},"end":{"line":67,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0338554382324ms
Sending response {"id": 2299, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2300,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0228881835938ms
Sending response {"id": 2300, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2301,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 2301, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2632},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functio\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2302,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":17},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0131130218506ms
Sending response {"id": 2302, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2635},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functionj \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2303,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 2303, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2304,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 2304, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2638},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functio\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2305,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":17},"end":{"line":67,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2305, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2306,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2306, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2307,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2307, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2639},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This functio \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2308,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2308, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2309,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2309, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2641},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2310,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":18},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2310, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2656},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always retursn\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2311,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":33},"end":{"line":67,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 2311, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2312,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2312, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2313,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2313, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2657},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always retursn \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2314,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2314, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2315,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2315, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2660},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always retur\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2316,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":31},"end":{"line":67,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 2316, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2317,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 2317, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2318,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2318, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2661},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always return\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2668},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns false\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2319,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":39},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 2319, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2320,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":39},"end":{"line":67,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 2320, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2321,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 2321, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2322,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2322, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2669},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns fals\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2323,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":38},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 2323, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2670},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns fal\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2324,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":37},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2324, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2671},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns fa\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2325,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":36},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0121593475342ms
Sending response {"id": 2325, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2325}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2672},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns f\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2326,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":35},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2326, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2326}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2677},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2327,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":38},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.032901763916ms
Sending response {"id": 2327, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2328,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":38},"end":{"line":67,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Sending response {"id": 2328, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2329,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2329, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2330,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0410079956055ms
Sending response {"id": 2330, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2331,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":38},"end":{"line":67,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0588893890381ms
Sending response {"id": 2331, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2678},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2332,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":39},"end":{"line":67,"character":39}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2332, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2333,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2333, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2334,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 2334, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2679},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2335,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 2335, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2336,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2336, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2681},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. NB\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2337,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2337, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2338,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":42},"end":{"line":67,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2338, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2339,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2339, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2340,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2340, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2683},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2341,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 2341, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2342,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0178813934326ms
Sending response {"id": 2342, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2684},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. B\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2343,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":41},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2343, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2686},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Bec\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2344,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":43},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2344, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2687},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Beca\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2345,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":44},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2345, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2688},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Becau\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2346,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":45},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2346, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2691},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2347,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2347, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2348,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2348, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2692},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because p\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2693},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2697},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2699},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pa\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2701},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the patt\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2704},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2711},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variab\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2714},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2715},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable i\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2349,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":70},"end":{"line":67,"character":70}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 2349, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2350,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2350, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2351,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2351, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2716},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2721},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2352,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2352, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2353,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 2353, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2728},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distric\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2354,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":81},"end":{"line":67,"character":81}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0829696655273ms
Sending response {"id": 2354, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2355,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 2355, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2356,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2356, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2731},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is dist\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2357,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":78},"end":{"line":67,"character":78}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2357, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2358,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 2358, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2359,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 2359, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2734},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinc\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2736},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2360,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0331401824951ms
Sending response {"id": 2360, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2361,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0240802764893ms
Sending response {"id": 2361, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2740},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2741},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2748},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the fun\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2362,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":67,"character":95},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2362, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2749},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the func\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2753},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2754},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2363,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":67,"character":100},"end":{"line":67,"character":100}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 2363, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2755},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2756},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\nv\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2763},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\nvariable\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2364,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":68,"character":8},"end":{"line":68,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0340938568115ms
Sending response {"id": 2364, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2365,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2365, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2366,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2366, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2773},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\nar\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2774},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narg\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2367,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":68,"character":3},"end":{"line":68,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Sending response {"id": 2367, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2368,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2368, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2369,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2369, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2775},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\nar\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2370,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":68,"character":2},"end":{"line":68,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 2370, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2371,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2371, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2372,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 2372, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2776},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\naru\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2782},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2783},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2373,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":68,"character":10},"end":{"line":68,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 2373, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2374,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 2374, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2375,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2375, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2784},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2376,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 2376, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2377,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 2377, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2786},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2378,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 2378, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2379,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2379, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2787},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nB\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2380,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":70,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2380, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2788},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBe\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2790},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBett\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2381,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":70,"character":4},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2381, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2791},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBette\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2382,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":70,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00309944152832ms
Sending response {"id": 2382, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2792},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2383,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":70,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2383, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2794},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter w\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2384,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":70,"character":8},"end":{"line":70,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 2384, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2385,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2385, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2386,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 2386, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2795},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter we\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2387,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":70,"character":9},"end":{"line":70,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 2387, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2388,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2388, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2389,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2389, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2798},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2801},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2390,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":70,"character":13},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00405311584473ms
Sending response {"id": 2390, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2827},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2391,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0269412994385ms
Sending response {"id": 2391, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2392,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2392, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2829},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nle\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2830},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2393,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":72,"character":3},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00715255737305ms
Sending response {"id": 2393, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2831},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2394,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2394, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2395,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 2395, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2832},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2833},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet le\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2396,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":72,"character":6},"end":{"line":72,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Sending response {"id": 2396, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2397,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 2397, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2398,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0269412994385ms
Sending response {"id": 2398, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2837},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2399,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":72,"character":10},"end":{"line":72,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 2399, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2400,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2400, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2401,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 2401, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2838},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2402,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":72,"character":11},"end":{"line":72,"character":11}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2402, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2403,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 2403, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2404,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2404, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2847},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2850},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2405,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0298023223877ms
Sending response {"id": 2405, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2406,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 2406, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2855},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2407,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":73,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0109672546387ms
Sending response {"id": 2407, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2856},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2857},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match L\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2408,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":73,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0150203704834ms
Sending response {"id": 2408, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2859},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match Lis\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2861},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2409,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":73,"character":13},"end":{"line":73,"character":13}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 2409, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2410,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2410, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2411,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 2411, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2865},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.leng\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2867},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2872},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2412,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2412, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2413,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2413, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2875},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst wit\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2414,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":73,"character":27},"end":{"line":73,"character":27}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2414, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2415,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 2415, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2416,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2416, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2876},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2417,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":73,"character":28},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0321865081787ms
Sending response {"id": 2417, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2418,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":73,"character":28},"end":{"line":73,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0269412994385ms
Sending response {"id": 2418, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2419,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 2419, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2420,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0112056732178ms
Sending response {"id": 2420, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2877},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2421,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 2421, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2422,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0250339508057ms
Sending response {"id": 2422, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2878},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2423,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 2423, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2424,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 2424, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2879},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  |\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2883},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2425,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":74,"character":7},"end":{"line":74,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 2425, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2426,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2426, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2427,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2427, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2886},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2428,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":74,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2428, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2890},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = b\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2429,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":74,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2429, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2430,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":74,"character":14},"end":{"line":74,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Sending response {"id": 2430, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2431,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2431, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2432,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00381469726562ms
Sending response {"id": 2432, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2433,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":74,"character":14},"end":{"line":74,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 2433, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2891},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2892},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2434,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":74,"character":14},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2434, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2435,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":74,"character":14},"end":{"line":74,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 2435, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2436,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0550746917725ms
Sending response {"id": 2436, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2437,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2437, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2893},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = nan\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2438,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":74,"character":16},"end":{"line":74,"character":16}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 2438, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2439,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 2439, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2440,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2440, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2894},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = nan\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2441,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 2441, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2895},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = nan\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2442,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 2442, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2898},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2899},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2443,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0369548797607ms
Sending response {"id": 2443, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2444,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0271797180176ms
Sending response {"id": 2444, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2900},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\n  \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2445,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2445, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2446,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2446, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2901},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2447,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 2447, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2448,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.592947006226ms
Sending response {"id": 2448, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2902},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\no\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2449,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":76,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2449, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2449}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2906},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2450,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 2450, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2451,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 2451, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2907},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nl\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2452,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00882148742676ms
Sending response {"id": 2452, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2910},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2453,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 2453, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2454,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2454, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2911},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2455,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":5},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 2455, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2912},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet le\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2456,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":6},"end":{"line":78,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2456, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2457,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Sending response {"id": 2457, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2458,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2458, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2913},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet leg\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2459,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":7},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2459, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2460,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":7},"end":{"line":78,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 2460, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2461,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2461, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2462,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 2462, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2914},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legt\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2463,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00810623168945ms
Sending response {"id": 2463, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2915},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2464,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":9},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2464, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2465,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":9},"end":{"line":78,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2465, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2466,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2466, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2467,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2467, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2916},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2468,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":10},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00476837158203ms
Sending response {"id": 2468, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2469,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":10},"end":{"line":78,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 2469, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2470,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2470, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2471,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2471, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2917},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_i\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2472,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":11},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2472, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2918},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2473,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":12},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2473, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2474,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":12},"end":{"line":78,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0348091125488ms
Sending response {"id": 2474, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2475,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 2475, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2476,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2476, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2921},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is ls\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2925},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2926},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n =\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2927},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2477,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0240802764893ms
Sending response {"id": 2477, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2478,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2478, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2928},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = L\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2479,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":22},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00691413879395ms
Sending response {"id": 2479, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2930},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = Lis\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2932},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2933},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2480,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":27},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0200271606445ms
Sending response {"id": 2480, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2934},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.le\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2481,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":28},"end":{"line":78,"character":28}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 2481, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2482,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0112056732178ms
Sending response {"id": 2482, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2935},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.len\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2483,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2483, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2484,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":29},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00596046447754ms
Sending response {"id": 2484, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2936},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.leng\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2485,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":30},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00619888305664ms
Sending response {"id": 2485, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2939},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.lengrth\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2486,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":33},"end":{"line":78,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2486, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2487,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 2487, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2488,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2488, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2943},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.lengt\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2489,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":31},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00786781311035ms
Sending response {"id": 2489, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2944},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2490,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":32},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0100135803223ms
Sending response {"id": 2490, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2945},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2491,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2491, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2492,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2492, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2946},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length l\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2493,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":34},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00905990600586ms
Sending response {"id": 2493, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2947},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length ls\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2949},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length lst \n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2494,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2494, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2495,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2495, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2950},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length lst\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2496,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":36},"end":{"line":78,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2496, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2497,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0197887420654ms
Sending response {"id": 2497, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2498,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2498, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2951},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = List.length lst)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2499,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":37},"end":{"line":78,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 2499, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2500,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 2500, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2501,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2501, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2502,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":36}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0128746032715ms
Sending response {"id": 2502, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2503,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":36},"end":{"line":78,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Sending response {"id": 2503, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2504,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 2504, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2505,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":32}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0240802764893ms
Sending response {"id": 2505, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2506,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":20},"end":{"line":78,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0410079956055ms
Sending response {"id": 2506, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2507,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2507, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2508,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":21}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0131130218506ms
Sending response {"id": 2508, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2509,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":21},"end":{"line":78,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0138282775879ms
Sending response {"id": 2509, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2510,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2510, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2952},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2511,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":22}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.0119209289551ms
Sending response {"id": 2511, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2512,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":22},"end":{"line":78,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0247955322266ms
Sending response {"id": 2512, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2513,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 2513, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2514,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 2514, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2515,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":23}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 2515, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2516,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2516, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2517,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":23},"end":{"line":78,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 2517, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2518,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":34}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Sending response {"id": 2518, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2519,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":38},"end":{"line":78,"character":38}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0348091125488ms
Sending response {"id": 2519, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2520,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 2520, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2953},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst) \n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2956},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst) = n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2521,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":78,"character":42},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.00500679016113ms
Sending response {"id": 2521, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2522,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":42},"end":{"line":78,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Sending response {"id": 2522, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2523,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2523, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2524,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2524, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2525,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":42},"end":{"line":78,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 2525, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2957},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst) = nan\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2526,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":44},"end":{"line":78,"character":44}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 2526, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2527,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2527, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2528,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2528, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2959},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n\n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst) = n\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2529,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":42},"end":{"line":78,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2529, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2530,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 2530, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2531,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2531, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2532,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":78,"character":42},"end":{"line":78,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0338554382324ms
Sending response {"id": 2532, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2533,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":60,"character":0},"end":{"line":78,"character":42}},"context":{"diagnostics":[{"range":{"start":{"line":61,"character":2},"end":{"line":61,"character":5}},"message":"Unbound constructor One","severity":1,"source":"merlin"},{"range":{"start":{"line":61,"character":6},"end":{"line":61,"character":8}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0569820404053ms
Sending response {"id": 2533, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2534,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 2534, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2960},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n(* \n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst) = n *)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2535,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":60,"character":3},"end":{"line":78,"character":42}},"context":{"diagnostics":[{"range":{"start":{"line":61,"character":2},"end":{"line":61,"character":5}},"message":"Unbound constructor One","severity":1,"source":"merlin"},{"range":{"start":{"line":61,"character":6},"end":{"line":61,"character":8}},"message":"Syntax error","severity":1,"source":"merlin"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0388622283936ms
Sending response {"id": 2535, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2536,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 2536, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2537,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2537, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2538,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":60,"character":3},"end":{"line":78,"character":42}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0171661376953ms
Sending response {"id": 2538, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2539,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":20}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0121593475342ms
Sending response {"id": 2539, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2540,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 2540, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2541,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"range":{"start":{"line":58,"character":20},"end":{"line":58,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2541, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2542,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 2542, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2543,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"},"position":{"line":58,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0519752502441ms
Sending response {"id": 2543, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2960},"contentChanges":[{"text":"(**\n  Pattern Matching with Lists\n*)\n\n(* Syntax\nmatch e with\n| p1 -> e1\n| p2 -> e2\n.....\n\nEach of the clauses p1 -> e1 is called a branch or case of pattern match\nThe p's here are called patterns. A pattern may be: \n  -> a variable name\n  -> The underscore character which is called wildcard\n  -> empty list\n  -> p1 :: p2 prepending\n  -> [p1;...;pn]\nNotes:\n  No variable name may appear more than once in a pattern. For example x :: x is illegal, but the wildcard\n  may occur any number of times. *)\n\n  (* Dynamic semantics:\n\n  match 1 :: [] with\n  | [] -> false\n  | h :: t -> h = 1 && t = []\n\n  -> 1 :: [] is already a value\n  -> [] does not match 1 :: []\n  -> h :: t does match 1 :: [] and produces variable bindings {h -> 1, t -> []} because: \n    - h matches 1 and produces the variable bindings h -> 1\n    - t matches [] and produces the variable binding t -> []\n  -> Substituting {h->1, t -> []} inside h = 1 && t = [] produces a new expression 1 = 1 && [] = []\n  -> Evaluating 1 = 1 && [] = [] yields the value true. We omit the justification for that fact here, but it follows\n  from other evaluation rules for built-in operators and function application.\n  -> So the result of the entier match expression is true. *)\n\n\n  (* Additional static checking:\n\n  In addition to that type-checking rule, there are two other checks the compiler does for each mathc expression\n\n  First, exhaustiveness. The compiler checks to make sure that there are enough patterns to guarantee that\n  at least one of them matches the expression e, no matter what the value of that expression is at run time.\n  This ensures that programmer did not forget any branches. For example, the function below will cause\n  the compiler to emit a warning.\n  let head lst = match lst with h :: _ -> h\n\n  Second, unused branches: the compiler checks to see whether any of the branches could never be matched\n  against because one of the previous branches is guaranteed to succeed. For example, the function below \n  will cause the compiler to emit a warning:\n\n  let rec sum lst = \n    match lst with\n    | h :: t -> h + sum t\n    | [ h ] -> h\n    | [] -> 0\n\n  Here second branch is unused because the first branch will match anything the second branch matches. *)\n\n(* \n  One of the good and common example of bugs that causes a unused match case warning.\n  let length_is lst n = \n    match List.length lst with \n    | n -> true\n    | _ -> false\n\nHere This function always returns true. Because the pattern variable n is distinct from the function\narument n. \n\nBetter way to write this is like this\n\nlet length_is lst n = \n  match List.length lst with\n  | m -> m = n\n\nor \n\nlet legth_is lst n = (List.length lst) = n *)\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml","version":2960}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","languageId":"ocaml","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2544,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2544, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2545,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 2545, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fourth_chapter/main.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":2},"contentChanges":[{"text":"\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2546,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 2546, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2547,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0441074371338ms
Sending response {"id": 2547, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":3},"contentChanges":[{"text":"\n()"}]}}
Read message 
{"jsonrpc":"2.0","id":2548,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"position":{"line":1,"character":1}}}
[server] Got a method textDocument/signatureHelp
[server] processing took 0.00500679016113ms
Sending response {"id": 2548, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":5},"contentChanges":[{"text":"\n(** *)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":9},"contentChanges":[{"text":"\n(**\n    \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2549,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0360012054443ms
Sending response {"id": 2549, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":10},"contentChanges":[{"text":"\n(**\n      \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2550,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0338554382324ms
Sending response {"id": 2550, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2551,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2551, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":11},"contentChanges":[{"text":"\n(**\n  \n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2552,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 2552, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2553,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2553, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":14},"contentChanges":[{"text":"\n(**\n  \nDee\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":15},"contentChanges":[{"text":"\n(**\n  \nDeep\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":16},"contentChanges":[{"text":"\n(**\n  \nDeep \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2554,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 2554, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2555,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2555, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":20},"contentChanges":[{"text":"\n(**\n  \nDeep Patt\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":23},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":24},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2556,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 2556, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2557,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Sending response {"id": 2557, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":27},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern mat\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":32},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":33},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2558,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0371932983398ms
Sending response {"id": 2558, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2559,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2559, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":34},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2560,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0369548797607ms
Sending response {"id": 2560, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2561,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2561, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":36},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPa\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2562,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":2},"end":{"line":5,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 2562, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2563,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2563, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2564,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2564, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":38},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatt\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":53},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nes\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":55},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nesrt\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2565,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":21},"end":{"line":5,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 2565, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2566,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 2566, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2567,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2567, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":56},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nesr\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2568,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":20},"end":{"line":5,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 2568, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2569,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 2569, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2570,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 2570, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":61},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested.\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2571,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":23},"end":{"line":5,"character":23}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 2571, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2572,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2572, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2573,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 2573, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":62},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2574,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 2574, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2575,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 2575, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":69},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":71},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2576,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":33},"end":{"line":5,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2576, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2577,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2577, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2578,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2578, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":82},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2579,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
Sending response {"id": 2579, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2580,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 2580, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":99},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":105},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deepl\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2581,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":67},"end":{"line":5,"character":67}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Sending response {"id": 2581, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2582,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2582, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2583,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2583, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":107},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":111},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":115},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":120},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the stur\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":124},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcutr\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2584,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":86},"end":{"line":5,"character":86}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 2584, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2585,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2585, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2586,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2586, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":126},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcutre \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2587,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 2587, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2588,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2588, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":131},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturc\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2589,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":83},"end":{"line":5,"character":83}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2589, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2590,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Sending response {"id": 2590, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2591,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2591, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":136},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2592,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2592, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2593,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00619888305664ms
Sending response {"id": 2593, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":142},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a l\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":146},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2594,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":5,"character":98},"end":{"line":5,"character":98}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2594, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2595,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2595, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2596,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2596, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":147},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":152},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor e\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":155},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor exam\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":158},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":160},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2597,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0338554382324ms
Sending response {"id": 2597, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2598,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0147819519043ms
Sending response {"id": 2598, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":161},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2599,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0309944152832ms
Sending response {"id": 2599, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2600,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2600, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":162},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2601,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":8,"character":1},"end":{"line":8,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Sending response {"id": 2601, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2602,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 2602, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2603,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0290870666504ms
Sending response {"id": 2603, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":163},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n->\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2604,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":8,"character":2},"end":{"line":8,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2604, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2605,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2605, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2606,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 2606, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":164},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2607,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 2607, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2608,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2608, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":166},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":169},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2609,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0121593475342ms
Sending response {"id": 2609, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2610,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2610, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":170},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2611,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":8,"character":9},"end":{"line":8,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 2611, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2612,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 2612, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2613,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2613, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":171},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: [] \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2614,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 2614, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2615,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0250339508057ms
Sending response {"id": 2615, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":172},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: [] -\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2616,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":8,"character":12},"end":{"line":8,"character":12}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0400543212891ms
Sending response {"id": 2616, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2617,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0190734863281ms
Sending response {"id": 2617, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2618,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2618, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":173},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: [] - \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2619,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 2619, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2620,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2620, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":176},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2621,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 2621, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2622,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Sending response {"id": 2622, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":184},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2623,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00619888305664ms
Sending response {"id": 2623, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2624,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2624, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":185},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches l\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2625,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":8,"character":21},"end":{"line":8,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.121116638184ms
Sending response {"id": 2625, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2626,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00381469726562ms
Sending response {"id": 2626, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2627,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2627, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":187},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches a\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":189},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":190},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":194},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all list\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":195},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":198},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists wi\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":200},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":202},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with e\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":205},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exac\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":207},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactl\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":221},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2628,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 2628, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2629,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.018835067749ms
Sending response {"id": 2629, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":222},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2630,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":9,"character":1},"end":{"line":9,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2630, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2631,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2631, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2632,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 2632, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":223},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n->\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":224},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2633,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0319480895996ms
Sending response {"id": 2633, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2634,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2634, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":226},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":229},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2635,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2635, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2636,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0171661376953ms
Sending response {"id": 2636, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":231},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2637,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Sending response {"id": 2637, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2638,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 2638, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":234},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ mat\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":238},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":239},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2639,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 2639, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2640,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 2640, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":242},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":244},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all l\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":248},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":249},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":251},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists wi\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":253},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":257},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":261},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at leas\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":263},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2641,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 2641, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2642,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2642, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":265},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least on\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":267},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2643,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 2643, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2644,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2644, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":268},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one e\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":275},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2645,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0348091125488ms
Sending response {"id": 2645, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2646,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0181198120117ms
Sending response {"id": 2646, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":276},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":278},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2647,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 2647, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2648,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 2648, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":280},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> : \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":282},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":287},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2649,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2649, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2650,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2650, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":288},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":289},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":293},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: []\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2651,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":10,"character":14},"end":{"line":10,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 2651, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2652,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Sending response {"id": 2652, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2653,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 2653, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":294},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2654,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2654, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2655,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2655, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":297},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] mat\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":302},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2656,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2656, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2657,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 2657, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":305},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":306},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":307},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all l\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":309},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lis\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2658,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":10,"character":31},"end":{"line":10,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 2658, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2659,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2659, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2660,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2660, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":311},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":312},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":314},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists wi\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2661,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":10,"character":36},"end":{"line":10,"character":36}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 2661, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2662,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2662, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2663,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0119209289551ms
Sending response {"id": 2663, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":315},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists wih\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2664,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":10,"character":37},"end":{"line":10,"character":37}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2664, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2665,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00596046447754ms
Sending response {"id": 2665, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2666,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2666, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":318},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":319},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2667,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2667, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2668,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2668, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":323},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exac\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":325},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactl\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":330},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2669,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":10,"character":50},"end":{"line":10,"character":50}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 2669, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2670,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 2670, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2671,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2671, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":331},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2672,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2672, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2673,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 2673, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":332},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two a\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2674,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":10,"character":52},"end":{"line":10,"character":52}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 2674, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2675,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 2675, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2676,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00405311584473ms
Sending response {"id": 2676, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":340},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two element\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":342},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2677,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 2677, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2678,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2678, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":343},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2679,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":1},"end":{"line":11,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2679, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2680,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 2680, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2681,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0128746032715ms
Sending response {"id": 2681, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":345},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2682,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2682, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2683,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 2683, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":346},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2684,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":4},"end":{"line":11,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0381469726562ms
Sending response {"id": 2684, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2685,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2685, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2686,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0121593475342ms
Sending response {"id": 2686, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":351},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2687,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":9},"end":{"line":11,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 2687, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2688,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2688, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2689,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2689, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":352},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":355},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":356},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2690,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":14},"end":{"line":11,"character":14}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0238418579102ms
Sending response {"id": 2690, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2691,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 2691, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2692,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2692, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":357},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2693,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 2693, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2694,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2694, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":359},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ ::\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2695,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":17},"end":{"line":11,"character":17}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 2695, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2696,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
Sending response {"id": 2696, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2697,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 2697, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":361},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":362},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2698,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
Sending response {"id": 2698, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2699,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0100135803223ms
Sending response {"id": 2699, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":367},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ match\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2700,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":25},"end":{"line":11,"character":25}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0388622283936ms
Sending response {"id": 2700, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2701,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2701, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2702,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0109672546387ms
Sending response {"id": 2702, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":369},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":373},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2703,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":31},"end":{"line":11,"character":31}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2703, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2704,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 2704, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2705,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 2705, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":374},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2706,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Sending response {"id": 2706, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2707,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2707, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":381},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all element\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":383},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all elements \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2708,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Sending response {"id": 2708, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2709,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 2709, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":384},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all elements\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2710,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":40},"end":{"line":11,"character":40}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0350475311279ms
Sending response {"id": 2710, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2711,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0250339508057ms
Sending response {"id": 2711, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2712,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 2712, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":387},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all eleme\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":391},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all e\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2713,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":33},"end":{"line":11,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 2713, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2714,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0231266021729ms
Sending response {"id": 2714, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2715,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 2715, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":392},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2716,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.032901763916ms
Sending response {"id": 2716, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2717,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 2717, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":393},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all l\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":397},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":398},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2718,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0340938568115ms
Sending response {"id": 2718, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2719,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0238418579102ms
Sending response {"id": 2719, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":402},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists with\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":406},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists with at \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":412},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists with at least \n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2720,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0219345092773ms
Sending response {"id": 2720, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2721,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0200271606445ms
Sending response {"id": 2721, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":426},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists with at least three elements\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","id":2722,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"},"range":{"start":{"line":11,"character":66},"end":{"line":11,"character":66}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0510215759277ms
Sending response {"id": 2722, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2723,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0259876251221ms
Sending response {"id": 2723, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":2724,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Sending response {"id": 2724, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":426},"contentChanges":[{"text":"\n(**\n  \nDeep Pattern matching\n\nPatterns can be nested. Dosing so can allow your code to look deeply into the sturcture of a list.\nFor example:\n\n-> _ :: []  matches all lists with exactly one element\n-> _ :: _ matches all lists with at least one element\n-> _ :: _ :: [] matches all lists with exactly two elements\n-> _ :: _ :: _ :: _ matches all lists with at least three elements\n\n\n*)"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml","version":426}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/ilialataria/Desktop/Ocaml%20For%20Students/lists/fifth_chapter/main.ml"}}}
